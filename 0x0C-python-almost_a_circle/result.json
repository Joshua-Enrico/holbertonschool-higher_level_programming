{"traceEvents": [{"ph": "M", "pid": 222711, "tid": 222711, "name": "process_name", "args": {"name": "MainProcess"}}, {"ph": "M", "pid": 222711, "tid": 222711, "name": "thread_name", "args": {"name": "MainThread"}}, {"pid": 222711, "tid": 222711, "ts": 161380620007.725, "dur": 0.578, "name": "__init__ (<frozen importlib._bootstrap>:143)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620009.748, "dur": 0.365, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620012.697, "dur": 0.413, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620013.463, "dur": 0.094, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620012.393, "dur": 1.592, "name": "__init__ (<frozen importlib._bootstrap>:58)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620015.691, "dur": 0.214, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620009.357, "dur": 6.717, "name": "_get_module_lock (<frozen importlib._bootstrap>:157)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620016.952, "dur": 0.209, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620016.746, "dur": 2.917, "name": "acquire (<frozen importlib._bootstrap>:78)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620008.997, "dur": 10.83, "name": "__enter__ (<frozen importlib._bootstrap>:147)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620020.423, "dur": 0.193, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620021.216, "dur": 0.444, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620024.855, "dur": 0.311, "name": "__init__ (<frozen importlib._bootstrap>:143)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620025.922, "dur": 0.147, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620027.369, "dur": 0.206, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620027.924, "dur": 0.123, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620027.186, "dur": 1.207, "name": "__init__ (<frozen importlib._bootstrap>:58)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620029.19, "dur": 0.132, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620025.721, "dur": 3.719, "name": "_get_module_lock (<frozen importlib._bootstrap>:157)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620029.91, "dur": 0.143, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620029.784, "dur": 1.681, "name": "acquire (<frozen importlib._bootstrap>:78)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620025.47, "dur": 6.143, "name": "__enter__ (<frozen importlib._bootstrap>:147)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620031.933, "dur": 0.14, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620032.647, "dur": 0.116, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620034.823, "dur": 0.125, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620034.6, "dur": 0.454, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620036.042, "dur": 0.883, "name": "_imp.is_builtin", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620035.71, "dur": 1.374, "name": "find_spec (<frozen importlib._bootstrap>:725)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620037.618, "dur": 0.119, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620037.426, "dur": 0.385, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620038.613, "dur": 0.088, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620038.49, "dur": 0.277, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620039.433, "dur": 0.261, "name": "_imp.is_frozen", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620039.205, "dur": 0.613, "name": "find_spec (<frozen importlib._bootstrap>:800)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620040.135, "dur": 0.093, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620040.002, "dur": 0.291, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620040.823, "dur": 0.083, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620040.703, "dur": 0.275, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620042.906, "dur": 0.197, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620047.784, "dur": 0.089, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620049.034, "dur": 6.536, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620048.614, "dur": 7.271, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620047.402, "dur": 12.633, "name": "__init__ (<frozen zipimport>:63)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620063.936, "dur": 3.561, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620063.596, "dur": 4.096, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620063.312, "dur": 5.182, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:90)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620062.918, "dur": 5.988, "name": "_path_isdir (<frozen importlib._bootstrap_external>:104)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620076.931, "dur": 0.255, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620077.307, "dur": 0.166, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620077.584, "dur": 0.121, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620077.801, "dur": 0.143, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620076.361, "dur": 2.661, "name": "list.extend", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620080.004, "dur": 0.168, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620080.274, "dur": 0.098, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620079.786, "dur": 0.988, "name": "list.extend", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620081.416, "dur": 0.167, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620081.673, "dur": 0.083, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620081.195, "dur": 0.852, "name": "list.extend", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620074.715, "dur": 9.467, "name": "__init__ (<frozen importlib._bootstrap_external>:1394)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620062.683, "dur": 21.923, "name": "path_hook_for_FileFinder (<frozen importlib._bootstrap_external>:1520)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620045.404, "dur": 39.57, "name": "_path_hooks (<frozen importlib._bootstrap_external>:1252)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620043.564, "dur": 42.382, "name": "_path_importer_cache (<frozen importlib._bootstrap_external>:1265)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620086.354, "dur": 0.387, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620087.363, "dur": 0.208, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620088.327, "dur": 4.444, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620088.065, "dur": 4.93, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620098.369, "dur": 36.552, "name": "posix.listdir", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620136.229, "dur": 0.705, "name": "str.startswith", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620141.306, "dur": 0.366, "name": "str.startswith", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620094.815, "dur": 47.052, "name": "_fill_cache (<frozen importlib._bootstrap_external>:1479)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620142.88, "dur": 0.187, "name": "_relax_case (<frozen importlib._bootstrap_external>:40)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620145.521, "dur": 0.221, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620146.095, "dur": 0.09, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620145.063, "dur": 1.261, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620146.625, "dur": 0.433, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620144.063, "dur": 3.137, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620148.473, "dur": 0.099, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620148.772, "dur": 0.158, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620148.286, "dur": 0.76, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620149.211, "dur": 0.229, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620147.993, "dur": 1.568, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620150.606, "dur": 8.983, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620150.319, "dur": 9.796, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620150.126, "dur": 11.502, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:90)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620149.891, "dur": 11.899, "name": "_path_isfile (<frozen importlib._bootstrap_external>:99)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620163.339, "dur": 0.129, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620163.714, "dur": 0.119, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620163.041, "dur": 0.951, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620164.177, "dur": 0.214, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620162.603, "dur": 1.897, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620165.306, "dur": 4.916, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620165.07, "dur": 5.505, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620164.93, "dur": 6.532, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:90)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620164.741, "dur": 9.758, "name": "_path_isfile (<frozen importlib._bootstrap_external>:99)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620176.764, "dur": 0.156, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620177.168, "dur": 0.113, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620176.373, "dur": 1.032, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620177.584, "dur": 0.2, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620175.872, "dur": 2.038, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620178.712, "dur": 4.913, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620178.507, "dur": 5.433, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620178.346, "dur": 6.424, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:90)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620178.154, "dur": 6.754, "name": "_path_isfile (<frozen importlib._bootstrap_external>:99)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620186.187, "dur": 0.126, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620186.546, "dur": 0.066, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620185.907, "dur": 0.823, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620186.919, "dur": 0.195, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620185.506, "dur": 1.723, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620187.96, "dur": 5.019, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620187.753, "dur": 5.445, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620187.612, "dur": 6.643, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:90)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620187.443, "dur": 7.36, "name": "_path_isfile (<frozen importlib._bootstrap_external>:99)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620196.365, "dur": 0.611, "name": "__init__ (<frozen importlib._bootstrap_external>:939)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620198.164, "dur": 0.133, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620199.994, "dur": 0.871, "name": "__init__ (<frozen importlib._bootstrap>:342)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620197.743, "dur": 4.305, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:629)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620195.636, "dur": 6.564, "name": "_get_spec (<frozen importlib._bootstrap_external>:1426)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620087.116, "dur": 115.445, "name": "find_spec (<frozen importlib._bootstrap_external>:1431)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620042.249, "dur": 160.823, "name": "_get_spec (<frozen importlib._bootstrap_external>:1302)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620041.607, "dur": 161.988, "name": "find_spec (<frozen importlib._bootstrap_external>:1334)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620204.388, "dur": 0.284, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620204.112, "dur": 0.67, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620033.391, "dur": 172.416, "name": "_find_spec (<frozen importlib._bootstrap>:890)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620206.803, "dur": 0.408, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620207.746, "dur": 0.136, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620208.241, "dur": 0.141, "name": "create_module (<frozen importlib._bootstrap_external>:774)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620208.732, "dur": 1.129, "name": "_new_module (<frozen importlib._bootstrap>:35)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620210.552, "dur": 0.262, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620211.006, "dur": 0.09, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620211.606, "dur": 0.088, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620212.099, "dur": 0.24, "name": "parent (<frozen importlib._bootstrap>:389)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620212.718, "dur": 2.503, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620216.037, "dur": 0.185, "name": "has_location (<frozen importlib._bootstrap>:397)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620216.441, "dur": 1.103, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620217.856, "dur": 0.878, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620220.346, "dur": 0.677, "name": "str.endswith", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620221.781, "dur": 0.076, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620222.362, "dur": 0.212, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620222.934, "dur": 0.427, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620222.101, "dur": 1.575, "name": "_path_split (<frozen importlib._bootstrap_external>:68)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620227.84, "dur": 0.249, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620229.026, "dur": 0.305, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620233.105, "dur": 0.18, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620233.493, "dur": 0.063, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620233.726, "dur": 0.063, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620232.791, "dur": 1.118, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620234.147, "dur": 0.216, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620232.261, "dur": 2.201, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620221.475, "dur": 13.131, "name": "cache_from_source (<frozen importlib._bootstrap_external>:294)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620219.643, "dur": 15.313, "name": "_get_cached (<frozen importlib._bootstrap_external>:424)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620218.998, "dur": 16.368, "name": "cached (<frozen importlib._bootstrap>:376)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620235.702, "dur": 0.203, "name": "cached (<frozen importlib._bootstrap>:376)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620210.245, "dur": 25.934, "name": "_init_module_attrs (<frozen importlib._bootstrap>:477)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620207.536, "dur": 28.876, "name": "module_from_spec (<frozen importlib._bootstrap>:549)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620239.486, "dur": 0.136, "name": "get_filename (<frozen importlib._bootstrap_external>:964)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620238.52, "dur": 1.231, "name": "_check_name_wrapper (<frozen importlib._bootstrap_external>:456)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620240.597, "dur": 0.112, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620241.138, "dur": 0.104, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620241.519, "dur": 0.198, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620240.926, "dur": 1.011, "name": "_path_split (<frozen importlib._bootstrap_external>:68)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620242.141, "dur": 0.115, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620242.736, "dur": 0.165, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620244.589, "dur": 0.109, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620244.895, "dur": 0.066, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620245.108, "dur": 0.067, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620244.341, "dur": 0.954, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620245.456, "dur": 0.172, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620244.056, "dur": 1.685, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620240.252, "dur": 5.628, "name": "cache_from_source (<frozen importlib._bootstrap_external>:294)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620247.024, "dur": 5.848, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620246.831, "dur": 6.279, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620246.611, "dur": 7.8, "name": "path_stats (<frozen importlib._bootstrap_external>:1010)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620256.706, "dur": 0.302, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620257.825, "dur": 18.887, "name": "io.open_code", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620278.167, "dur": 5.889, "name": "_io.BufferedReader.read", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620256.343, "dur": 33.162, "name": "get_data (<frozen importlib._bootstrap_external>:969)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620292.835, "dur": 0.193, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620293.678, "dur": 0.072, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620294.592, "dur": 0.322, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620293.537, "dur": 1.555, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620291.622, "dur": 4.131, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:493)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620298.533, "dur": 0.092, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620298.867, "dur": 0.128, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620298.428, "dur": 0.672, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620299.847, "dur": 0.07, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620300.102, "dur": 0.095, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620299.738, "dur": 3.621, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620298.143, "dur": 6.124, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:526)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620305.624, "dur": 0.718, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620307.499, "dur": 3.138, "name": "marshal.loads", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620310.933, "dur": 0.159, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620311.488, "dur": 0.261, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620312.228, "dur": 0.543, "name": "_imp._fix_co_filename", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620307.102, "dur": 5.777, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:578)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620237.995, "dur": 75.091, "name": "get_code (<frozen importlib._bootstrap_external>:849)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620315.706, "dur": 0.124, "name": "<module> (./models/__init__.py:1)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620314.994, "dur": 0.999, "name": "builtins.exec", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620314.724, "dur": 1.368, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:211)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620237.54, "dur": 78.753, "name": "exec_module (<frozen importlib._bootstrap_external>:777)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620317.148, "dur": 0.336, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620318.332, "dur": 0.258, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620206.447, "dur": 112.633, "name": "_load_unlocked (<frozen importlib._bootstrap>:650)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620032.493, "dur": 286.858, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:956)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620320.715, "dur": 0.305, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620320.43, "dur": 2.792, "name": "release (<frozen importlib._bootstrap>:103)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620319.984, "dur": 3.437, "name": "__exit__ (<frozen importlib._bootstrap>:151)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620324.436, "dur": 0.154, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620324.879, "dur": 0.185, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620325.546, "dur": 0.128, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620324.256, "dur": 1.507, "name": "cb (<frozen importlib._bootstrap>:176)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620024.426, "dur": 302.381, "name": "_find_and_load (<frozen importlib._bootstrap>:986)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620023.053, "dur": 304.201, "name": "builtins.__import__", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620022.68, "dur": 304.667, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:211)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620330.007, "dur": 0.102, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620329.864, "dur": 0.34, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620330.735, "dur": 0.153, "name": "find_spec (<frozen importlib._bootstrap>:725)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620331.351, "dur": 0.117, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620331.184, "dur": 0.364, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620332.184, "dur": 0.086, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620332.072, "dur": 0.269, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620332.939, "dur": 0.353, "name": "_imp.is_frozen", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620332.686, "dur": 0.734, "name": "find_spec (<frozen importlib._bootstrap>:800)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620333.795, "dur": 0.095, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620333.648, "dur": 0.31, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620334.504, "dur": 0.085, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620334.388, "dur": 0.264, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620335.948, "dur": 0.149, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620339.512, "dur": 0.079, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620340.472, "dur": 6.381, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620340.177, "dur": 6.936, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620339.285, "dur": 11.369, "name": "__init__ (<frozen zipimport>:63)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620354.21, "dur": 3.636, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620353.926, "dur": 4.108, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620353.747, "dur": 8.271, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:90)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620353.482, "dur": 9.054, "name": "_path_isdir (<frozen importlib._bootstrap_external>:104)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620366.059, "dur": 0.209, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620366.381, "dur": 0.166, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620366.634, "dur": 0.12, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620366.855, "dur": 0.126, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620365.649, "dur": 2.304, "name": "list.extend", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620368.883, "dur": 0.168, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620369.138, "dur": 0.101, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620368.689, "dur": 0.934, "name": "list.extend", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620370.223, "dur": 0.129, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620370.454, "dur": 0.08, "name": "<genexpr> (<frozen importlib._bootstrap_external>:1400)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620370.033, "dur": 0.781, "name": "list.extend", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620364.086, "dur": 8.362, "name": "__init__ (<frozen importlib._bootstrap_external>:1394)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620353.257, "dur": 19.56, "name": "path_hook_for_FileFinder (<frozen importlib._bootstrap_external>:1520)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620338.333, "dur": 34.797, "name": "_path_hooks (<frozen importlib._bootstrap_external>:1252)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620336.436, "dur": 38.976, "name": "_path_importer_cache (<frozen importlib._bootstrap_external>:1265)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620375.793, "dur": 0.37, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620376.806, "dur": 0.452, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620378.109, "dur": 4.473, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620377.864, "dur": 4.925, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620384.838, "dur": 18.082, "name": "posix.listdir", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620403.966, "dur": 0.696, "name": "str.startswith", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620406.909, "dur": 0.33, "name": "str.startswith", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620384.322, "dur": 23.115, "name": "_fill_cache (<frozen importlib._bootstrap_external>:1479)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620408.295, "dur": 0.148, "name": "_relax_case (<frozen importlib._bootstrap_external>:40)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620410.7, "dur": 0.247, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620411.265, "dur": 0.164, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620410.303, "dur": 1.254, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620411.84, "dur": 0.384, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620409.746, "dur": 2.618, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620413.301, "dur": 0.597, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620415.15, "dur": 0.099, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620415.431, "dur": 0.091, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620414.963, "dur": 0.679, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620415.833, "dur": 0.179, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620414.683, "dur": 1.439, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620416.58, "dur": 0.239, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620417.84, "dur": 0.092, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620418.101, "dur": 0.086, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620417.682, "dur": 0.607, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620418.441, "dur": 0.164, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620417.468, "dur": 1.241, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620419.057, "dur": 0.218, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620420.186, "dur": 0.093, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620420.445, "dur": 0.067, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620420.031, "dur": 3.679, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620424.5, "dur": 0.262, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620419.814, "dur": 5.083, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620425.708, "dur": 0.358, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620427.567, "dur": 5.369, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620427.285, "dur": 5.86, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620427.067, "dur": 7.009, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:90)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620426.845, "dur": 7.699, "name": "_path_isfile (<frozen importlib._bootstrap_external>:99)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620435.799, "dur": 0.511, "name": "__init__ (<frozen importlib._bootstrap_external>:939)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620437.373, "dur": 0.118, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620438.513, "dur": 0.727, "name": "__init__ (<frozen importlib._bootstrap>:342)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620436.955, "dur": 3.534, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:629)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620435.145, "dur": 5.509, "name": "_get_spec (<frozen importlib._bootstrap_external>:1426)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620376.552, "dur": 64.378, "name": "find_spec (<frozen importlib._bootstrap_external>:1431)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620335.447, "dur": 106.008, "name": "_get_spec (<frozen importlib._bootstrap_external>:1302)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620335.043, "dur": 106.982, "name": "find_spec (<frozen importlib._bootstrap_external>:1334)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620442.819, "dur": 0.26, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620442.537, "dur": 0.655, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620328.523, "dur": 115.6, "name": "_find_spec (<frozen importlib._bootstrap>:890)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620445.029, "dur": 0.411, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620445.942, "dur": 0.118, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620446.364, "dur": 0.096, "name": "create_module (<frozen importlib._bootstrap_external>:774)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620446.779, "dur": 1.057, "name": "_new_module (<frozen importlib._bootstrap>:35)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620448.457, "dur": 0.202, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620448.859, "dur": 0.091, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620449.445, "dur": 0.086, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620450.232, "dur": 0.444, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620449.904, "dur": 1.142, "name": "parent (<frozen importlib._bootstrap>:389)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620451.442, "dur": 2.439, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620454.264, "dur": 0.164, "name": "has_location (<frozen importlib._bootstrap>:397)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620454.641, "dur": 0.972, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620456.32, "dur": 0.873, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620458.795, "dur": 0.569, "name": "str.endswith", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620460.067, "dur": 0.069, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620460.611, "dur": 0.198, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620461.101, "dur": 0.169, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620460.37, "dur": 1.226, "name": "_path_split (<frozen importlib._bootstrap_external>:68)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620461.84, "dur": 0.139, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620462.667, "dur": 0.252, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620465.862, "dur": 0.192, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620466.301, "dur": 0.067, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620466.521, "dur": 0.064, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620465.594, "dur": 1.125, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620466.981, "dur": 0.205, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620465.004, "dur": 2.299, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620459.745, "dur": 7.715, "name": "cache_from_source (<frozen importlib._bootstrap_external>:294)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620458.105, "dur": 9.643, "name": "_get_cached (<frozen importlib._bootstrap_external>:424)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620457.451, "dur": 14.233, "name": "cached (<frozen importlib._bootstrap>:376)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620472.127, "dur": 0.208, "name": "cached (<frozen importlib._bootstrap>:376)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620448.181, "dur": 24.439, "name": "_init_module_attrs (<frozen importlib._bootstrap>:477)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620445.718, "dur": 27.18, "name": "module_from_spec (<frozen importlib._bootstrap>:549)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620475.997, "dur": 0.172, "name": "get_filename (<frozen importlib._bootstrap_external>:964)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620474.932, "dur": 1.366, "name": "_check_name_wrapper (<frozen importlib._bootstrap_external>:456)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620477.083, "dur": 0.131, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620477.596, "dur": 0.135, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620478.02, "dur": 0.281, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620477.394, "dur": 1.14, "name": "_path_split (<frozen importlib._bootstrap_external>:68)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620478.73, "dur": 0.125, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620479.348, "dur": 0.202, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620481.553, "dur": 0.136, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620481.906, "dur": 0.064, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620482.11, "dur": 0.066, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620481.305, "dur": 0.992, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620482.479, "dur": 0.179, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620480.952, "dur": 1.817, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620476.771, "dur": 6.141, "name": "cache_from_source (<frozen importlib._bootstrap_external>:294)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620483.85, "dur": 5.606, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620483.65, "dur": 6.033, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620483.438, "dur": 7.148, "name": "path_stats (<frozen importlib._bootstrap_external>:1010)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620492.707, "dur": 0.3, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620493.674, "dur": 18.216, "name": "io.open_code", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620513.318, "dur": 6.585, "name": "_io.BufferedReader.read", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620492.362, "dur": 32.92, "name": "get_data (<frozen importlib._bootstrap_external>:969)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620528.65, "dur": 0.246, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620529.642, "dur": 0.064, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620530.282, "dur": 0.254, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620529.459, "dur": 1.253, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620527.432, "dur": 3.88, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:493)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620533.795, "dur": 0.094, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620534.123, "dur": 0.128, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620533.705, "dur": 0.637, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620535.101, "dur": 0.087, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620535.382, "dur": 0.097, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620534.986, "dur": 0.577, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620533.418, "dur": 2.423, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:526)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620536.78, "dur": 0.585, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620538.292, "dur": 24.359, "name": "marshal.loads", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620562.992, "dur": 0.191, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620563.708, "dur": 0.34, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620564.489, "dur": 0.988, "name": "_imp._fix_co_filename", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620538.001, "dur": 27.575, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:578)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620474.473, "dur": 91.363, "name": "get_code (<frozen importlib._bootstrap_external>:849)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620570.937, "dur": 0.594, "name": "__init__ (<frozen importlib._bootstrap>:143)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620572.702, "dur": 0.214, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620579.805, "dur": 0.378, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620580.659, "dur": 0.102, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620579.499, "dur": 1.689, "name": "__init__ (<frozen importlib._bootstrap>:58)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620582.697, "dur": 0.224, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620572.478, "dur": 10.578, "name": "_get_module_lock (<frozen importlib._bootstrap>:157)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620583.798, "dur": 0.222, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620583.639, "dur": 2.942, "name": "acquire (<frozen importlib._bootstrap>:78)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620572.136, "dur": 14.595, "name": "__enter__ (<frozen importlib._bootstrap>:147)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620587.367, "dur": 0.192, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620588.214, "dur": 0.402, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620591.682, "dur": 0.119, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620591.53, "dur": 0.391, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620592.468, "dur": 3.034, "name": "find_spec (<frozen importlib._bootstrap>:725)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620596.238, "dur": 0.168, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620595.995, "dur": 0.498, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620597.405, "dur": 0.091, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620597.261, "dur": 0.314, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620598.177, "dur": 0.336, "name": "_imp.is_frozen", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620597.963, "dur": 0.673, "name": "find_spec (<frozen importlib._bootstrap>:800)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620598.963, "dur": 0.097, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620598.835, "dur": 0.301, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620599.674, "dur": 0.078, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620599.541, "dur": 0.289, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620601.393, "dur": 0.173, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620601.956, "dur": 0.581, "name": "_path_importer_cache (<frozen importlib._bootstrap_external>:1265)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620602.918, "dur": 0.333, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620603.833, "dur": 0.198, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620604.997, "dur": 10.108, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620604.631, "dur": 10.715, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620617.259, "dur": 0.132, "name": "_relax_case (<frozen importlib._bootstrap_external>:40)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620619.93, "dur": 0.252, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620620.522, "dur": 0.159, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620619.488, "dur": 1.322, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620621.164, "dur": 0.35, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620618.833, "dur": 2.862, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620622.54, "dur": 0.579, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620624.379, "dur": 0.103, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620624.7, "dur": 0.101, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620624.203, "dur": 0.709, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620625.097, "dur": 0.196, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620623.943, "dur": 1.469, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620625.834, "dur": 0.256, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620627.043, "dur": 0.093, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620627.313, "dur": 0.091, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620626.875, "dur": 0.63, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620627.683, "dur": 0.179, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620626.644, "dur": 3.708, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620631.28, "dur": 0.363, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620633.102, "dur": 0.14, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620633.436, "dur": 0.065, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620632.872, "dur": 0.746, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620633.816, "dur": 0.164, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620632.493, "dur": 1.579, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620634.45, "dur": 0.236, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620636.189, "dur": 4.812, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620635.768, "dur": 5.439, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620635.572, "dur": 6.643, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:90)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620635.328, "dur": 7.412, "name": "_path_isfile (<frozen importlib._bootstrap_external>:99)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620644.046, "dur": 0.635, "name": "__init__ (<frozen importlib._bootstrap_external>:939)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620645.792, "dur": 0.119, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620647.005, "dur": 0.805, "name": "__init__ (<frozen importlib._bootstrap>:342)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620645.367, "dur": 3.685, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:629)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620643.364, "dur": 5.872, "name": "_get_spec (<frozen importlib._bootstrap_external>:1426)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620603.608, "dur": 45.968, "name": "find_spec (<frozen importlib._bootstrap_external>:1431)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620600.783, "dur": 49.383, "name": "_get_spec (<frozen importlib._bootstrap_external>:1302)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620600.352, "dur": 50.365, "name": "find_spec (<frozen importlib._bootstrap_external>:1334)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620651.407, "dur": 0.258, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620651.172, "dur": 0.598, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620590.391, "dur": 62.218, "name": "_find_spec (<frozen importlib._bootstrap>:890)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620653.658, "dur": 0.346, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620654.482, "dur": 0.105, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620654.936, "dur": 0.095, "name": "create_module (<frozen importlib._bootstrap_external>:774)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620655.389, "dur": 1.082, "name": "_new_module (<frozen importlib._bootstrap>:35)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620657.156, "dur": 0.217, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620657.555, "dur": 0.093, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620658.153, "dur": 0.091, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620658.965, "dur": 0.334, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620658.633, "dur": 0.968, "name": "parent (<frozen importlib._bootstrap>:389)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620660.013, "dur": 2.469, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620662.896, "dur": 0.148, "name": "has_location (<frozen importlib._bootstrap>:397)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620663.252, "dur": 1.076, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620664.986, "dur": 0.918, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620667.514, "dur": 0.683, "name": "str.endswith", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620668.883, "dur": 0.092, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620669.47, "dur": 0.197, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620669.968, "dur": 0.306, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620669.215, "dur": 1.339, "name": "_path_split (<frozen importlib._bootstrap_external>:68)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620670.841, "dur": 0.145, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620671.69, "dur": 0.301, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620675.083, "dur": 0.173, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620675.497, "dur": 0.066, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620675.73, "dur": 0.065, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620674.677, "dur": 1.248, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620682.443, "dur": 0.345, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620674.148, "dur": 8.817, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620668.563, "dur": 14.649, "name": "cache_from_source (<frozen importlib._bootstrap_external>:294)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620666.864, "dur": 16.758, "name": "_get_cached (<frozen importlib._bootstrap_external>:424)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620666.193, "dur": 17.945, "name": "cached (<frozen importlib._bootstrap>:376)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620684.531, "dur": 0.223, "name": "cached (<frozen importlib._bootstrap>:376)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620656.859, "dur": 28.194, "name": "_init_module_attrs (<frozen importlib._bootstrap>:477)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620654.256, "dur": 31.015, "name": "module_from_spec (<frozen importlib._bootstrap>:549)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620688.54, "dur": 0.163, "name": "get_filename (<frozen importlib._bootstrap_external>:964)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620687.492, "dur": 1.353, "name": "_check_name_wrapper (<frozen importlib._bootstrap_external>:456)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620689.628, "dur": 0.127, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620690.159, "dur": 0.106, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620690.552, "dur": 0.263, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620689.929, "dur": 1.099, "name": "_path_split (<frozen importlib._bootstrap_external>:68)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620691.242, "dur": 0.151, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620691.909, "dur": 0.2, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620694.22, "dur": 0.133, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620694.573, "dur": 0.066, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620694.783, "dur": 0.066, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620693.993, "dur": 0.976, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620695.141, "dur": 0.184, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620693.619, "dur": 1.822, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620689.328, "dur": 6.29, "name": "cache_from_source (<frozen importlib._bootstrap_external>:294)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620696.626, "dur": 5.995, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620696.407, "dur": 6.442, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620696.156, "dur": 7.712, "name": "path_stats (<frozen importlib._bootstrap_external>:1010)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620706.009, "dur": 0.346, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620707.057, "dur": 18.969, "name": "io.open_code", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620730.359, "dur": 6.709, "name": "_io.BufferedReader.read", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620705.616, "dur": 36.89, "name": "get_data (<frozen importlib._bootstrap_external>:969)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620745.897, "dur": 0.241, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620746.842, "dur": 0.079, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620747.51, "dur": 0.247, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620746.722, "dur": 1.184, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620744.651, "dur": 3.81, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:493)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620750.934, "dur": 0.093, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620751.255, "dur": 0.124, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620750.844, "dur": 0.622, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620753.521, "dur": 0.657, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620750.55, "dur": 5.771, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:526)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620758.53, "dur": 0.26, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620759.382, "dur": 15.889, "name": "io.open_code", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620776.517, "dur": 15.944, "name": "_io.BufferedReader.read", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620758.22, "dur": 39.415, "name": "get_data (<frozen importlib._bootstrap_external>:969)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621195.348, "dur": 3.75, "name": "__init__ (/usr/lib/python3.8/warnings.py:403)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621212.821, "dur": 0.572, "name": "str.startswith", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621217.938, "dur": 7.43, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621228.07, "dur": 18.557, "name": "io.open", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621251.997, "dur": 6.116, "name": "_io.BufferedReader.readline", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621251.766, "dur": 6.629, "name": "read_or_stop (/usr/lib/python3.8/tokenize.py:319)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621259.811, "dur": 1.809, "name": "bytes.startswith", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621262.692, "dur": 0.431, "name": "bytes.decode", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621263.631, "dur": 2.354, "name": "re.Pattern.match", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621262.277, "dur": 3.893, "name": "find_cookie (/usr/lib/python3.8/tokenize.py:325)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621266.666, "dur": 1.391, "name": "re.Pattern.match", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621268.751, "dur": 0.269, "name": "_io.BufferedReader.readline", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621268.648, "dur": 0.443, "name": "read_or_stop (/usr/lib/python3.8/tokenize.py:319)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621269.481, "dur": 0.202, "name": "bytes.decode", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621269.87, "dur": 0.257, "name": "re.Pattern.match", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621269.336, "dur": 0.915, "name": "find_cookie (/usr/lib/python3.8/tokenize.py:325)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621248.798, "dur": 21.909, "name": "detect_encoding (/usr/lib/python3.8/tokenize.py:295)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621271.518, "dur": 0.842, "name": "_io.BufferedReader.seek", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621280.841, "dur": 0.818, "name": "__init__ (/usr/lib/python3.8/codecs.py:260)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621279.904, "dur": 2.069, "name": "__init__ (/usr/lib/python3.8/codecs.py:309)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621227.551, "dur": 56.732, "name": "open (/usr/lib/python3.8/tokenize.py:388)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621289.735, "dur": 1.124, "name": "_codecs.utf_8_decode", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621288.862, "dur": 2.925, "name": "decode (/usr/lib/python3.8/codecs.py:319)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621309.488, "dur": 0.654, "name": "_codecs.utf_8_decode", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621308.78, "dur": 2.094, "name": "decode (/usr/lib/python3.8/codecs.py:319)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621285.921, "dur": 25.519, "name": "_io.TextIOWrapper.readlines", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621319.164, "dur": 0.541, "name": "str.endswith", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621212.097, "dur": 108.852, "name": "updatecache (/usr/lib/python3.8/linecache.py:82)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621210.571, "dur": 112.932, "name": "getlines (/usr/lib/python3.8/linecache.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621324.246, "dur": 0.182, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621209.877, "dur": 114.901, "name": "getline (/usr/lib/python3.8/linecache.py:15)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621325.703, "dur": 0.512, "name": "str.strip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621203.501, "dur": 124.607, "name": "_formatwarnmsg_impl (/usr/lib/python3.8/warnings.py:35)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621202.309, "dur": 126.173, "name": "_formatwarnmsg (/usr/lib/python3.8/warnings.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621329.483, "dur": 23.571, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621201.184, "dur": 152.389, "name": "_showwarnmsg_impl (/usr/lib/python3.8/warnings.py:20)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621199.854, "dur": 154.272, "name": "_showwarnmsg (/usr/lib/python3.8/warnings.py:96)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621363.335, "dur": 5.233, "name": "__init__ (/usr/lib/python3.8/warnings.py:403)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621374.992, "dur": 0.178, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621374.436, "dur": 1.231, "name": "getlines (/usr/lib/python3.8/linecache.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621375.966, "dur": 0.092, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621374.181, "dur": 2.218, "name": "getline (/usr/lib/python3.8/linecache.py:15)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621376.807, "dur": 0.28, "name": "str.strip", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621370.667, "dur": 7.687, "name": "_formatwarnmsg_impl (/usr/lib/python3.8/warnings.py:35)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621370.344, "dur": 8.204, "name": "_formatwarnmsg (/usr/lib/python3.8/warnings.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621378.933, "dur": 7.02, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621369.714, "dur": 16.631, "name": "_showwarnmsg_impl (/usr/lib/python3.8/warnings.py:20)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621369.164, "dur": 17.512, "name": "_showwarnmsg (/usr/lib/python3.8/warnings.py:96)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620802.885, "dur": 629.652, "name": "builtins.compile", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620802.606, "dur": 634.088, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:211)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620800.931, "dur": 636.635, "name": "source_to_code (<frozen importlib._bootstrap_external>:841)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621439.698, "dur": 0.797, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621442.008, "dur": 0.3, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621446.457, "dur": 0.718, "name": "int.to_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621445.524, "dur": 1.83, "name": "_pack_uint32 (<frozen importlib._bootstrap_external>:46)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621447.608, "dur": 0.63, "name": "bytearray.extend", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621448.808, "dur": 0.245, "name": "int.to_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621448.504, "dur": 0.66, "name": "_pack_uint32 (<frozen importlib._bootstrap_external>:46)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621449.297, "dur": 0.16, "name": "bytearray.extend", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621449.906, "dur": 0.175, "name": "int.to_bytes", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621449.632, "dur": 0.559, "name": "_pack_uint32 (<frozen importlib._bootstrap_external>:46)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621450.307, "dur": 0.164, "name": "bytearray.extend", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621451.099, "dur": 18.407, "name": "marshal.dumps", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621469.656, "dur": 1.413, "name": "bytearray.extend", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621442.96, "dur": 28.345, "name": "_code_to_timestamp_pyc (<frozen importlib._bootstrap_external>:591)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621476.795, "dur": 7.33, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621476.29, "dur": 8.067, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621475.999, "dur": 10.098, "name": "_calc_mode (<frozen importlib._bootstrap_external>:436)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621488.657, "dur": 0.229, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621489.463, "dur": 0.507, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621488.347, "dur": 2.068, "name": "_path_split (<frozen importlib._bootstrap_external>:68)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621491.657, "dur": 4.147, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621491.452, "dur": 4.563, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621491.278, "dur": 5.55, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:90)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621490.966, "dur": 6.339, "name": "_path_isdir (<frozen importlib._bootstrap_external>:104)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621501.388, "dur": 0.441, "name": "builtins.id", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621501.998, "dur": 2.608, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621506.289, "dur": 42.226, "name": "posix.open", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621554.879, "dur": 24.51, "name": "_io.FileIO.write", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621586.439, "dur": 112.215, "name": "posix.replace", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621500.574, "dur": 198.809, "name": "_write_atomic (<frozen importlib._bootstrap_external>:120)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621702.837, "dur": 0.921, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621488.023, "dur": 216.063, "name": "set_data (<frozen importlib._bootstrap_external>:1020)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621475.268, "dur": 229.591, "name": "_cache_bytecode (<frozen importlib._bootstrap_external>:1015)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620686.992, "dur": 1018.329, "name": "get_code (<frozen importlib._bootstrap_external>:849)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621712.05, "dur": 3.439, "name": "Base (./models/base.py:10)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621710.97, "dur": 20.971, "name": "builtins.__build_class__", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621709.132, "dur": 23.191, "name": "<module> (./models/base.py:2)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621708.223, "dur": 24.345, "name": "builtins.exec", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621707.893, "dur": 24.778, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:211)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620686.631, "dur": 1046.372, "name": "exec_module (<frozen importlib._bootstrap_external>:777)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621734.419, "dur": 0.292, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621735.737, "dur": 0.401, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620653.316, "dur": 1083.381, "name": "_load_unlocked (<frozen importlib._bootstrap>:650)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621737.607, "dur": 0.422, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621738.434, "dur": 5.106, "name": "builtins.setattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620587.963, "dur": 1156.199, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:956)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621746.418, "dur": 0.484, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621746.039, "dur": 3.793, "name": "release (<frozen importlib._bootstrap>:103)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621745.401, "dur": 4.641, "name": "__exit__ (<frozen importlib._bootstrap>:151)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621751.251, "dur": 0.182, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621751.757, "dur": 0.238, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621752.49, "dur": 0.162, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621750.969, "dur": 1.785, "name": "cb (<frozen importlib._bootstrap>:176)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620570.308, "dur": 1183.514, "name": "_find_and_load (<frozen importlib._bootstrap>:986)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621764.062, "dur": 0.965, "name": "property.setter", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621766.223, "dur": 0.276, "name": "property.setter", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621767.151, "dur": 0.233, "name": "property.setter", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621767.881, "dur": 0.197, "name": "property.setter", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621761.395, "dur": 8.162, "name": "Rectangle (./models/rectangle.py:7)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621757.673, "dur": 27.511, "name": "builtins.__build_class__", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620568.404, "dur": 1217.132, "name": "<module> (./models/rectangle.py:2)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620567.721, "dur": 1218.22, "name": "builtins.exec", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620567.428, "dur": 1218.644, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:211)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620474.076, "dur": 1312.387, "name": "exec_module (<frozen importlib._bootstrap_external>:777)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621788.024, "dur": 0.217, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621789.191, "dur": 0.54, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620444.641, "dur": 1345.49, "name": "_load_unlocked (<frozen importlib._bootstrap>:650)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621790.882, "dur": 0.52, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621791.755, "dur": 1.336, "name": "builtins.setattr", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620020.966, "dur": 1772.249, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:956)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621794.561, "dur": 0.273, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621794.281, "dur": 2.625, "name": "release (<frozen importlib._bootstrap>:103)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621793.862, "dur": 3.258, "name": "__exit__ (<frozen importlib._bootstrap>:151)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621798.08, "dur": 0.151, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621798.474, "dur": 0.171, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621799.012, "dur": 0.116, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621797.905, "dur": 1.306, "name": "cb (<frozen importlib._bootstrap>:176)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620007.027, "dur": 1792.856, "name": "_find_and_load (<frozen importlib._bootstrap>:986)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621804.348, "dur": 1.252, "name": "width (./models/rectangle.py:20)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621805.947, "dur": 0.595, "name": "height (./models/rectangle.py:32)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621806.804, "dur": 0.479, "name": "x (./models/rectangle.py:44)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621807.537, "dur": 0.477, "name": "y (./models/rectangle.py:56)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621809.129, "dur": 2.004, "name": "__init__ (./models/base.py:14)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621803.786, "dur": 7.589, "name": "__init__ (./models/rectangle.py:9)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621812.762, "dur": 0.344, "name": "x (./models/rectangle.py:40)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621813.599, "dur": 0.324, "name": "y (./models/rectangle.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621814.498, "dur": 0.259, "name": "height (./models/rectangle.py:28)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621815.101, "dur": 0.295, "name": "width (./models/rectangle.py:16)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621812.241, "dur": 3.309, "name": "to_dictionary (./models/rectangle.py:109)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621818.365, "dur": 0.572, "name": "width (./models/rectangle.py:20)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621819.15, "dur": 0.299, "name": "height (./models/rectangle.py:32)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621824.068, "dur": 0.71, "name": "x (./models/rectangle.py:44)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621824.988, "dur": 0.576, "name": "y (./models/rectangle.py:56)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621826.549, "dur": 1.229, "name": "__init__ (./models/base.py:14)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621818.09, "dur": 9.867, "name": "__init__ (./models/rectangle.py:9)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621817.301, "dur": 11.1, "name": "create (./models/base.py:47)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621834.626, "dur": 2.315, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621833.639, "dur": 3.53, "name": "__str__ (./models/rectangle.py:77)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621829.796, "dur": 20.189, "name": "builtins.print", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621852.692, "dur": 1.602, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621851.607, "dur": 2.867, "name": "__str__ (./models/rectangle.py:77)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621850.589, "dur": 11.014, "name": "builtins.print", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621862.243, "dur": 5.924, "name": "builtins.print", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380621868.798, "dur": 5.405, "name": "builtins.print", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620004.894, "dur": 1869.604, "name": "<module> (/home/joshua/Holberton/holbertonschool-higher_level_programming/0x0C-python-almost_a_circle/17-main.py:2)", "ph": "X", "cat": "FEE"}, {"pid": 222711, "tid": 222711, "ts": 161380620003.962, "dur": 1871.009, "name": "builtins.exec", "ph": "X", "cat": "FEE"}], "viztracer_metadata": {"version": "0.13.3"}, "displayTimeUnit": "us", "file_info": {"files": {"./models/__init__.py": ["", 0], "/usr/lib/python3.8/warnings.py": ["\"\"\"Python part of the warnings subsystem.\"\"\"\n\nimport sys\n\n\n__all__ = [\"warn\", \"warn_explicit\", \"showwarning\",\n           \"formatwarning\", \"filterwarnings\", \"simplefilter\",\n           \"resetwarnings\", \"catch_warnings\"]\n\ndef showwarning(message, category, filename, lineno, file=None, line=None):\n    \"\"\"Hook to write a warning to a file; replace if you like.\"\"\"\n    msg = WarningMessage(message, category, filename, lineno, file, line)\n    _showwarnmsg_impl(msg)\n\ndef formatwarning(message, category, filename, lineno, line=None):\n    \"\"\"Function to format a warning the standard way.\"\"\"\n    msg = WarningMessage(message, category, filename, lineno, None, line)\n    return _formatwarnmsg_impl(msg)\n\ndef _showwarnmsg_impl(msg):\n    file = msg.file\n    if file is None:\n        file = sys.stderr\n        if file is None:\n            # sys.stderr is None when run with pythonw.exe:\n            # warnings get lost\n            return\n    text = _formatwarnmsg(msg)\n    try:\n        file.write(text)\n    except OSError:\n        # the file (probably stderr) is invalid - this warning gets lost.\n        pass\n\ndef _formatwarnmsg_impl(msg):\n    category = msg.category.__name__\n    s =  f\"{msg.filename}:{msg.lineno}: {category}: {msg.message}\\n\"\n\n    if msg.line is None:\n        try:\n            import linecache\n            line = linecache.getline(msg.filename, msg.lineno)\n        except Exception:\n            # When a warning is logged during Python shutdown, linecache\n            # and the import machinery don't work anymore\n            line = None\n            linecache = None\n    else:\n        line = msg.line\n    if line:\n        line = line.strip()\n        s += \"  %s\\n\" % line\n\n    if msg.source is not None:\n        try:\n            import tracemalloc\n        # Logging a warning should not raise a new exception:\n        # catch Exception, not only ImportError and RecursionError.\n        except Exception:\n            # don't suggest to enable tracemalloc if it's not available\n            tracing = True\n            tb = None\n        else:\n            tracing = tracemalloc.is_tracing()\n            try:\n                tb = tracemalloc.get_object_traceback(msg.source)\n            except Exception:\n                # When a warning is logged during Python shutdown, tracemalloc\n                # and the import machinery don't work anymore\n                tb = None\n\n        if tb is not None:\n            s += 'Object allocated at (most recent call last):\\n'\n            for frame in tb:\n                s += ('  File \"%s\", lineno %s\\n'\n                      % (frame.filename, frame.lineno))\n\n                try:\n                    if linecache is not None:\n                        line = linecache.getline(frame.filename, frame.lineno)\n                    else:\n                        line = None\n                except Exception:\n                    line = None\n                if line:\n                    line = line.strip()\n                    s += '    %s\\n' % line\n        elif not tracing:\n            s += (f'{category}: Enable tracemalloc to get the object '\n                  f'allocation traceback\\n')\n    return s\n\n# Keep a reference to check if the function was replaced\n_showwarning_orig = showwarning\n\ndef _showwarnmsg(msg):\n    \"\"\"Hook to write a warning to a file; replace if you like.\"\"\"\n    try:\n        sw = showwarning\n    except NameError:\n        pass\n    else:\n        if sw is not _showwarning_orig:\n            # warnings.showwarning() was replaced\n            if not callable(sw):\n                raise TypeError(\"warnings.showwarning() must be set to a \"\n                                \"function or method\")\n\n            sw(msg.message, msg.category, msg.filename, msg.lineno,\n               msg.file, msg.line)\n            return\n    _showwarnmsg_impl(msg)\n\n# Keep a reference to check if the function was replaced\n_formatwarning_orig = formatwarning\n\ndef _formatwarnmsg(msg):\n    \"\"\"Function to format a warning the standard way.\"\"\"\n    try:\n        fw = formatwarning\n    except NameError:\n        pass\n    else:\n        if fw is not _formatwarning_orig:\n            # warnings.formatwarning() was replaced\n            return fw(msg.message, msg.category,\n                      msg.filename, msg.lineno, msg.line)\n    return _formatwarnmsg_impl(msg)\n\ndef filterwarnings(action, message=\"\", category=Warning, module=\"\", lineno=0,\n                   append=False):\n    \"\"\"Insert an entry into the list of warnings filters (at the front).\n\n    'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n                or \"once\"\n    'message' -- a regex that the warning message must match\n    'category' -- a class that the warning must be a subclass of\n    'module' -- a regex that the module name must match\n    'lineno' -- an integer line number, 0 matches all warnings\n    'append' -- if true, append to the list of filters\n    \"\"\"\n    assert action in (\"error\", \"ignore\", \"always\", \"default\", \"module\",\n                      \"once\"), \"invalid action: %r\" % (action,)\n    assert isinstance(message, str), \"message must be a string\"\n    assert isinstance(category, type), \"category must be a class\"\n    assert issubclass(category, Warning), \"category must be a Warning subclass\"\n    assert isinstance(module, str), \"module must be a string\"\n    assert isinstance(lineno, int) and lineno >= 0, \\\n           \"lineno must be an int >= 0\"\n\n    if message or module:\n        import re\n\n    if message:\n        message = re.compile(message, re.I)\n    else:\n        message = None\n    if module:\n        module = re.compile(module)\n    else:\n        module = None\n\n    _add_filter(action, message, category, module, lineno, append=append)\n\ndef simplefilter(action, category=Warning, lineno=0, append=False):\n    \"\"\"Insert a simple entry into the list of warnings filters (at the front).\n\n    A simple filter matches all modules and messages.\n    'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n                or \"once\"\n    'category' -- a class that the warning must be a subclass of\n    'lineno' -- an integer line number, 0 matches all warnings\n    'append' -- if true, append to the list of filters\n    \"\"\"\n    assert action in (\"error\", \"ignore\", \"always\", \"default\", \"module\",\n                      \"once\"), \"invalid action: %r\" % (action,)\n    assert isinstance(lineno, int) and lineno >= 0, \\\n           \"lineno must be an int >= 0\"\n    _add_filter(action, None, category, None, lineno, append=append)\n\ndef _add_filter(*item, append):\n    # Remove possible duplicate filters, so new one will be placed\n    # in correct place. If append=True and duplicate exists, do nothing.\n    if not append:\n        try:\n            filters.remove(item)\n        except ValueError:\n            pass\n        filters.insert(0, item)\n    else:\n        if item not in filters:\n            filters.append(item)\n    _filters_mutated()\n\ndef resetwarnings():\n    \"\"\"Clear the list of warning filters, so that no filters are active.\"\"\"\n    filters[:] = []\n    _filters_mutated()\n\nclass _OptionError(Exception):\n    \"\"\"Exception used by option processing helpers.\"\"\"\n    pass\n\n# Helper to process -W options passed via sys.warnoptions\ndef _processoptions(args):\n    for arg in args:\n        try:\n            _setoption(arg)\n        except _OptionError as msg:\n            print(\"Invalid -W option ignored:\", msg, file=sys.stderr)\n\n# Helper for _processoptions()\ndef _setoption(arg):\n    parts = arg.split(':')\n    if len(parts) > 5:\n        raise _OptionError(\"too many fields (max 5): %r\" % (arg,))\n    while len(parts) < 5:\n        parts.append('')\n    action, message, category, module, lineno = [s.strip()\n                                                 for s in parts]\n    action = _getaction(action)\n    category = _getcategory(category)\n    if message or module:\n        import re\n    if message:\n        message = re.escape(message)\n    if module:\n        module = re.escape(module) + r'\\Z'\n    if lineno:\n        try:\n            lineno = int(lineno)\n            if lineno < 0:\n                raise ValueError\n        except (ValueError, OverflowError):\n            raise _OptionError(\"invalid lineno %r\" % (lineno,)) from None\n    else:\n        lineno = 0\n    filterwarnings(action, message, category, module, lineno)\n\n# Helper for _setoption()\ndef _getaction(action):\n    if not action:\n        return \"default\"\n    if action == \"all\": return \"always\" # Alias\n    for a in ('default', 'always', 'ignore', 'module', 'once', 'error'):\n        if a.startswith(action):\n            return a\n    raise _OptionError(\"invalid action: %r\" % (action,))\n\n# Helper for _setoption()\ndef _getcategory(category):\n    if not category:\n        return Warning\n    if '.' not in category:\n        import builtins as m\n        klass = category\n    else:\n        module, _, klass = category.rpartition('.')\n        try:\n            m = __import__(module, None, None, [klass])\n        except ImportError:\n            raise _OptionError(\"invalid module name: %r\" % (module,)) from None\n    try:\n        cat = getattr(m, klass)\n    except AttributeError:\n        raise _OptionError(\"unknown warning category: %r\" % (category,)) from None\n    if not issubclass(cat, Warning):\n        raise _OptionError(\"invalid warning category: %r\" % (category,))\n    return cat\n\n\ndef _is_internal_frame(frame):\n    \"\"\"Signal whether the frame is an internal CPython implementation detail.\"\"\"\n    filename = frame.f_code.co_filename\n    return 'importlib' in filename and '_bootstrap' in filename\n\n\ndef _next_external_frame(frame):\n    \"\"\"Find the next frame that doesn't involve CPython internals.\"\"\"\n    frame = frame.f_back\n    while frame is not None and _is_internal_frame(frame):\n        frame = frame.f_back\n    return frame\n\n\n# Code typically replaced by _warnings\ndef warn(message, category=None, stacklevel=1, source=None):\n    \"\"\"Issue a warning, or maybe ignore it or raise an exception.\"\"\"\n    # Check if message is already a Warning object\n    if isinstance(message, Warning):\n        category = message.__class__\n    # Check category argument\n    if category is None:\n        category = UserWarning\n    if not (isinstance(category, type) and issubclass(category, Warning)):\n        raise TypeError(\"category must be a Warning subclass, \"\n                        \"not '{:s}'\".format(type(category).__name__))\n    # Get context information\n    try:\n        if stacklevel <= 1 or _is_internal_frame(sys._getframe(1)):\n            # If frame is too small to care or if the warning originated in\n            # internal code, then do not try to hide any frames.\n            frame = sys._getframe(stacklevel)\n        else:\n            frame = sys._getframe(1)\n            # Look for one frame less since the above line starts us off.\n            for x in range(stacklevel-1):\n                frame = _next_external_frame(frame)\n                if frame is None:\n                    raise ValueError\n    except ValueError:\n        globals = sys.__dict__\n        filename = \"sys\"\n        lineno = 1\n    else:\n        globals = frame.f_globals\n        filename = frame.f_code.co_filename\n        lineno = frame.f_lineno\n    if '__name__' in globals:\n        module = globals['__name__']\n    else:\n        module = \"<string>\"\n    registry = globals.setdefault(\"__warningregistry__\", {})\n    warn_explicit(message, category, filename, lineno, module, registry,\n                  globals, source)\n\ndef warn_explicit(message, category, filename, lineno,\n                  module=None, registry=None, module_globals=None,\n                  source=None):\n    lineno = int(lineno)\n    if module is None:\n        module = filename or \"<unknown>\"\n        if module[-3:].lower() == \".py\":\n            module = module[:-3] # XXX What about leading pathname?\n    if registry is None:\n        registry = {}\n    if registry.get('version', 0) != _filters_version:\n        registry.clear()\n        registry['version'] = _filters_version\n    if isinstance(message, Warning):\n        text = str(message)\n        category = message.__class__\n    else:\n        text = message\n        message = category(message)\n    key = (text, category, lineno)\n    # Quick test for common case\n    if registry.get(key):\n        return\n    # Search the filters\n    for item in filters:\n        action, msg, cat, mod, ln = item\n        if ((msg is None or msg.match(text)) and\n            issubclass(category, cat) and\n            (mod is None or mod.match(module)) and\n            (ln == 0 or lineno == ln)):\n            break\n    else:\n        action = defaultaction\n    # Early exit actions\n    if action == \"ignore\":\n        return\n\n    # Prime the linecache for formatting, in case the\n    # \"file\" is actually in a zipfile or something.\n    import linecache\n    linecache.getlines(filename, module_globals)\n\n    if action == \"error\":\n        raise message\n    # Other actions\n    if action == \"once\":\n        registry[key] = 1\n        oncekey = (text, category)\n        if onceregistry.get(oncekey):\n            return\n        onceregistry[oncekey] = 1\n    elif action == \"always\":\n        pass\n    elif action == \"module\":\n        registry[key] = 1\n        altkey = (text, category, 0)\n        if registry.get(altkey):\n            return\n        registry[altkey] = 1\n    elif action == \"default\":\n        registry[key] = 1\n    else:\n        # Unrecognized actions are errors\n        raise RuntimeError(\n              \"Unrecognized action (%r) in warnings.filters:\\n %s\" %\n              (action, item))\n    # Print message and context\n    msg = WarningMessage(message, category, filename, lineno, source)\n    _showwarnmsg(msg)\n\n\nclass WarningMessage(object):\n\n    _WARNING_DETAILS = (\"message\", \"category\", \"filename\", \"lineno\", \"file\",\n                        \"line\", \"source\")\n\n    def __init__(self, message, category, filename, lineno, file=None,\n                 line=None, source=None):\n        self.message = message\n        self.category = category\n        self.filename = filename\n        self.lineno = lineno\n        self.file = file\n        self.line = line\n        self.source = source\n        self._category_name = category.__name__ if category else None\n\n    def __str__(self):\n        return (\"{message : %r, category : %r, filename : %r, lineno : %s, \"\n                    \"line : %r}\" % (self.message, self._category_name,\n                                    self.filename, self.lineno, self.line))\n\n\nclass catch_warnings(object):\n\n    \"\"\"A context manager that copies and restores the warnings filter upon\n    exiting the context.\n\n    The 'record' argument specifies whether warnings should be captured by a\n    custom implementation of warnings.showwarning() and be appended to a list\n    returned by the context manager. Otherwise None is returned by the context\n    manager. The objects appended to the list are arguments whose attributes\n    mirror the arguments to showwarning().\n\n    The 'module' argument is to specify an alternative module to the module\n    named 'warnings' and imported under that name. This argument is only useful\n    when testing the warnings module itself.\n\n    \"\"\"\n\n    def __init__(self, *, record=False, module=None):\n        \"\"\"Specify whether to record warnings and if an alternative module\n        should be used other than sys.modules['warnings'].\n\n        For compatibility with Python 3.0, please consider all arguments to be\n        keyword-only.\n\n        \"\"\"\n        self._record = record\n        self._module = sys.modules['warnings'] if module is None else module\n        self._entered = False\n\n    def __repr__(self):\n        args = []\n        if self._record:\n            args.append(\"record=True\")\n        if self._module is not sys.modules['warnings']:\n            args.append(\"module=%r\" % self._module)\n        name = type(self).__name__\n        return \"%s(%s)\" % (name, \", \".join(args))\n\n    def __enter__(self):\n        if self._entered:\n            raise RuntimeError(\"Cannot enter %r twice\" % self)\n        self._entered = True\n        self._filters = self._module.filters\n        self._module.filters = self._filters[:]\n        self._module._filters_mutated()\n        self._showwarning = self._module.showwarning\n        self._showwarnmsg_impl = self._module._showwarnmsg_impl\n        if self._record:\n            log = []\n            self._module._showwarnmsg_impl = log.append\n            # Reset showwarning() to the default implementation to make sure\n            # that _showwarnmsg() calls _showwarnmsg_impl()\n            self._module.showwarning = self._module._showwarning_orig\n            return log\n        else:\n            return None\n\n    def __exit__(self, *exc_info):\n        if not self._entered:\n            raise RuntimeError(\"Cannot exit %r without entering first\" % self)\n        self._module.filters = self._filters\n        self._module._filters_mutated()\n        self._module.showwarning = self._showwarning\n        self._module._showwarnmsg_impl = self._showwarnmsg_impl\n\n\n# Private utility function called by _PyErr_WarnUnawaitedCoroutine\ndef _warn_unawaited_coroutine(coro):\n    msg_lines = [\n        f\"coroutine '{coro.__qualname__}' was never awaited\\n\"\n    ]\n    if coro.cr_origin is not None:\n        import linecache, traceback\n        def extract():\n            for filename, lineno, funcname in reversed(coro.cr_origin):\n                line = linecache.getline(filename, lineno)\n                yield (filename, lineno, funcname, line)\n        msg_lines.append(\"Coroutine created at (most recent call last)\\n\")\n        msg_lines += traceback.format_list(list(extract()))\n    msg = \"\".join(msg_lines).rstrip(\"\\n\")\n    # Passing source= here means that if the user happens to have tracemalloc\n    # enabled and tracking where the coroutine was created, the warning will\n    # contain that traceback. This does mean that if they have *both*\n    # coroutine origin tracking *and* tracemalloc enabled, they'll get two\n    # partially-redundant tracebacks. If we wanted to be clever we could\n    # probably detect this case and avoid it, but for now we don't bother.\n    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)\n\n\n# filters contains a sequence of filter 5-tuples\n# The components of the 5-tuple are:\n# - an action: error, ignore, always, default, module, or once\n# - a compiled regex that must match the warning message\n# - a class representing the warning category\n# - a compiled regex that must match the module that is being warned\n# - a line number for the line being warning, or 0 to mean any line\n# If either if the compiled regexs are None, match anything.\ntry:\n    from _warnings import (filters, _defaultaction, _onceregistry,\n                           warn, warn_explicit, _filters_mutated)\n    defaultaction = _defaultaction\n    onceregistry = _onceregistry\n    _warnings_defaults = True\nexcept ImportError:\n    filters = []\n    defaultaction = \"default\"\n    onceregistry = {}\n\n    _filters_version = 1\n\n    def _filters_mutated():\n        global _filters_version\n        _filters_version += 1\n\n    _warnings_defaults = False\n\n\n# Module initialization\n_processoptions(sys.warnoptions)\nif not _warnings_defaults:\n    # Several warning categories are ignored by default in regular builds\n    if not hasattr(sys, 'gettotalrefcount'):\n        filterwarnings(\"default\", category=DeprecationWarning,\n                       module=\"__main__\", append=1)\n        simplefilter(\"ignore\", category=DeprecationWarning, append=1)\n        simplefilter(\"ignore\", category=PendingDeprecationWarning, append=1)\n        simplefilter(\"ignore\", category=ImportWarning, append=1)\n        simplefilter(\"ignore\", category=ResourceWarning, append=1)\n\ndel _warnings_defaults\n", 549], "/usr/lib/python3.8/tokenize.py": ["\"\"\"Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.\n\"\"\"\n\n__author__ = 'Ka-Ping Yee <ping@lfw.org>'\n__credits__ = ('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '\n               'Skip Montanaro, Raymond Hettinger, Trent Nelson, '\n               'Michael Foord')\nfrom builtins import open as _builtin_open\nfrom codecs import lookup, BOM_UTF8\nimport collections\nfrom io import TextIOWrapper\nimport itertools as _itertools\nimport re\nimport sys\nfrom token import *\nfrom token import EXACT_TOKEN_TYPES\n\ncookie_re = re.compile(r'^[ \\t\\f]*#.*?coding[:=][ \\t]*([-\\w.]+)', re.ASCII)\nblank_re = re.compile(br'^[ \\t\\f]*(?:[#\\r\\n]|$)', re.ASCII)\n\nimport token\n__all__ = token.__all__ + [\"tokenize\", \"generate_tokens\", \"detect_encoding\",\n                           \"untokenize\", \"TokenInfo\"]\ndel token\n\nclass TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):\n    def __repr__(self):\n        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])\n        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %\n                self._replace(type=annotated_type))\n\n    @property\n    def exact_type(self):\n        if self.type == OP and self.string in EXACT_TOKEN_TYPES:\n            return EXACT_TOKEN_TYPES[self.string]\n        else:\n            return self.type\n\ndef group(*choices): return '(' + '|'.join(choices) + ')'\ndef any(*choices): return group(*choices) + '*'\ndef maybe(*choices): return group(*choices) + '?'\n\n# Note: we use unicode matching for names (\"\\w\") but ascii matching for\n# number literals.\nWhitespace = r'[ \\f\\t]*'\nComment = r'#[^\\r\\n]*'\nIgnore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)\nName = r'\\w+'\n\nHexnumber = r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber = r'0[bB](?:_?[01])+'\nOctnumber = r'0[oO](?:_?[0-7])+'\nDecnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nExpfloat = r'[0-9](?:_?[0-9])*' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n\n# Return the empty string, plus all of the valid string prefixes.\ndef _all_string_prefixes():\n    # The valid string prefixes. Only contain the lower case versions,\n    #  and don't contain any permutations (include 'fr', but not\n    #  'rf'). The various permutations will be generated.\n    _valid_string_prefixes = ['b', 'r', 'u', 'f', 'br', 'fr']\n    # if we add binary f-strings, add: ['fb', 'fbr']\n    result = {''}\n    for prefix in _valid_string_prefixes:\n        for t in _itertools.permutations(prefix):\n            # create a list with upper and lower versions of each\n            #  character\n            for u in _itertools.product(*[(c, c.upper()) for c in t]):\n                result.add(''.join(u))\n    return result\n\ndef _compile(expr):\n    return re.compile(expr, re.UNICODE)\n\n# Note that since _all_string_prefixes includes the empty string,\n#  StringPrefix can be the empty string (making it optional).\nStringPrefix = group(*_all_string_prefixes())\n\n# Tail end of ' string.\nSingle = r\"[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"\n# Tail end of \" string.\nDouble = r'[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'\n# Tail end of ''' string.\nSingle3 = r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"\n# Tail end of \"\"\" string.\nDouble3 = r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"')\n# Single-line ' or \" string.\nString = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\n               StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n\n# Sorting in reverse order puts the long operators before their prefixes.\n# Otherwise if = came before ==, == would get recognized as two instances\n# of =.\nSpecial = group(*map(re.escape, sorted(EXACT_TOKEN_TYPES, reverse=True)))\nFunny = group(r'\\r?\\n', Special)\n\nPlainToken = group(Number, Funny, String, Name)\nToken = Ignore + PlainToken\n\n# First (or only) line of ' or \" string.\nContStr = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\" +\n                group(\"'\", r'\\\\\\r?\\n'),\n                StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*' +\n                group('\"', r'\\\\\\r?\\n'))\nPseudoExtras = group(r'\\\\\\r?\\n|\\Z', Comment, Triple)\nPseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n\n# For a given string prefix plus quotes, endpats maps it to a regex\n#  to match the remainder of that string. _prefix can be empty, for\n#  a normal single or triple quoted string (with no prefix).\nendpats = {}\nfor _prefix in _all_string_prefixes():\n    endpats[_prefix + \"'\"] = Single\n    endpats[_prefix + '\"'] = Double\n    endpats[_prefix + \"'''\"] = Single3\n    endpats[_prefix + '\"\"\"'] = Double3\n\n# A set of all of the single and triple quoted string prefixes,\n#  including the opening quotes.\nsingle_quoted = set()\ntriple_quoted = set()\nfor t in _all_string_prefixes():\n    for u in (t + '\"', t + \"'\"):\n        single_quoted.add(u)\n    for u in (t + '\"\"\"', t + \"'''\"):\n        triple_quoted.add(u)\n\ntabsize = 8\n\nclass TokenError(Exception): pass\n\nclass StopTokenizing(Exception): pass\n\n\nclass Untokenizer:\n\n    def __init__(self):\n        self.tokens = []\n        self.prev_row = 1\n        self.prev_col = 0\n        self.encoding = None\n\n    def add_whitespace(self, start):\n        row, col = start\n        if row < self.prev_row or row == self.prev_row and col < self.prev_col:\n            raise ValueError(\"start ({},{}) precedes previous end ({},{})\"\n                             .format(row, col, self.prev_row, self.prev_col))\n        row_offset = row - self.prev_row\n        if row_offset:\n            self.tokens.append(\"\\\\\\n\" * row_offset)\n            self.prev_col = 0\n        col_offset = col - self.prev_col\n        if col_offset:\n            self.tokens.append(\" \" * col_offset)\n\n    def untokenize(self, iterable):\n        it = iter(iterable)\n        indents = []\n        startline = False\n        for t in it:\n            if len(t) == 2:\n                self.compat(t, it)\n                break\n            tok_type, token, start, end, line = t\n            if tok_type == ENCODING:\n                self.encoding = token\n                continue\n            if tok_type == ENDMARKER:\n                break\n            if tok_type == INDENT:\n                indents.append(token)\n                continue\n            elif tok_type == DEDENT:\n                indents.pop()\n                self.prev_row, self.prev_col = end\n                continue\n            elif tok_type in (NEWLINE, NL):\n                startline = True\n            elif startline and indents:\n                indent = indents[-1]\n                if start[1] >= len(indent):\n                    self.tokens.append(indent)\n                    self.prev_col = len(indent)\n                startline = False\n            self.add_whitespace(start)\n            self.tokens.append(token)\n            self.prev_row, self.prev_col = end\n            if tok_type in (NEWLINE, NL):\n                self.prev_row += 1\n                self.prev_col = 0\n        return \"\".join(self.tokens)\n\n    def compat(self, token, iterable):\n        indents = []\n        toks_append = self.tokens.append\n        startline = token[0] in (NEWLINE, NL)\n        prevstring = False\n\n        for tok in _itertools.chain([token], iterable):\n            toknum, tokval = tok[:2]\n            if toknum == ENCODING:\n                self.encoding = tokval\n                continue\n\n            if toknum in (NAME, NUMBER):\n                tokval += ' '\n\n            # Insert a space between two consecutive strings\n            if toknum == STRING:\n                if prevstring:\n                    tokval = ' ' + tokval\n                prevstring = True\n            else:\n                prevstring = False\n\n            if toknum == INDENT:\n                indents.append(tokval)\n                continue\n            elif toknum == DEDENT:\n                indents.pop()\n                continue\n            elif toknum in (NEWLINE, NL):\n                startline = True\n            elif startline and indents:\n                toks_append(indents[-1])\n                startline = False\n            toks_append(tokval)\n\n\ndef untokenize(iterable):\n    \"\"\"Transform tokens back into Python source code.\n    It returns a bytes object, encoded using the ENCODING\n    token, which is the first token sequence output by tokenize.\n\n    Each element returned by the iterable must be a token sequence\n    with at least two elements, a token number and token value.  If\n    only two tokens are passed, the resulting output is poor.\n\n    Round-trip invariant for full input:\n        Untokenized source will match input source exactly\n\n    Round-trip invariant for limited input:\n        # Output bytes will tokenize back to the input\n        t1 = [tok[:2] for tok in tokenize(f.readline)]\n        newcode = untokenize(t1)\n        readline = BytesIO(newcode).readline\n        t2 = [tok[:2] for tok in tokenize(readline)]\n        assert t1 == t2\n    \"\"\"\n    ut = Untokenizer()\n    out = ut.untokenize(iterable)\n    if ut.encoding is not None:\n        out = out.encode(ut.encoding)\n    return out\n\n\ndef _get_normal_name(orig_enc):\n    \"\"\"Imitates get_normal_name in tokenizer.c.\"\"\"\n    # Only care about the first 12 characters.\n    enc = orig_enc[:12].lower().replace(\"_\", \"-\")\n    if enc == \"utf-8\" or enc.startswith(\"utf-8-\"):\n        return \"utf-8\"\n    if enc in (\"latin-1\", \"iso-8859-1\", \"iso-latin-1\") or \\\n       enc.startswith((\"latin-1-\", \"iso-8859-1-\", \"iso-latin-1-\")):\n        return \"iso-8859-1\"\n    return orig_enc\n\ndef detect_encoding(readline):\n    \"\"\"\n    The detect_encoding() function is used to detect the encoding that should\n    be used to decode a Python source file.  It requires one argument, readline,\n    in the same way as the tokenize() generator.\n\n    It will call readline a maximum of twice, and return the encoding used\n    (as a string) and a list of any lines (left as bytes) it has read in.\n\n    It detects the encoding from the presence of a utf-8 bom or an encoding\n    cookie as specified in pep-0263.  If both a bom and a cookie are present,\n    but disagree, a SyntaxError will be raised.  If the encoding cookie is an\n    invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,\n    'utf-8-sig' is returned.\n\n    If no encoding is specified, then the default of 'utf-8' will be returned.\n    \"\"\"\n    try:\n        filename = readline.__self__.name\n    except AttributeError:\n        filename = None\n    bom_found = False\n    encoding = None\n    default = 'utf-8'\n    def read_or_stop():\n        try:\n            return readline()\n        except StopIteration:\n            return b''\n\n    def find_cookie(line):\n        try:\n            # Decode as UTF-8. Either the line is an encoding declaration,\n            # in which case it should be pure ASCII, or it must be UTF-8\n            # per default encoding.\n            line_string = line.decode('utf-8')\n        except UnicodeDecodeError:\n            msg = \"invalid or missing encoding declaration\"\n            if filename is not None:\n                msg = '{} for {!r}'.format(msg, filename)\n            raise SyntaxError(msg)\n\n        match = cookie_re.match(line_string)\n        if not match:\n            return None\n        encoding = _get_normal_name(match.group(1))\n        try:\n            codec = lookup(encoding)\n        except LookupError:\n            # This behaviour mimics the Python interpreter\n            if filename is None:\n                msg = \"unknown encoding: \" + encoding\n            else:\n                msg = \"unknown encoding for {!r}: {}\".format(filename,\n                        encoding)\n            raise SyntaxError(msg)\n\n        if bom_found:\n            if encoding != 'utf-8':\n                # This behaviour mimics the Python interpreter\n                if filename is None:\n                    msg = 'encoding problem: utf-8'\n                else:\n                    msg = 'encoding problem for {!r}: utf-8'.format(filename)\n                raise SyntaxError(msg)\n            encoding += '-sig'\n        return encoding\n\n    first = read_or_stop()\n    if first.startswith(BOM_UTF8):\n        bom_found = True\n        first = first[3:]\n        default = 'utf-8-sig'\n    if not first:\n        return default, []\n\n    encoding = find_cookie(first)\n    if encoding:\n        return encoding, [first]\n    if not blank_re.match(first):\n        return default, [first]\n\n    second = read_or_stop()\n    if not second:\n        return default, [first]\n\n    encoding = find_cookie(second)\n    if encoding:\n        return encoding, [first, second]\n\n    return default, [first, second]\n\n\ndef open(filename):\n    \"\"\"Open a file in read only mode using the encoding detected by\n    detect_encoding().\n    \"\"\"\n    buffer = _builtin_open(filename, 'rb')\n    try:\n        encoding, lines = detect_encoding(buffer.readline)\n        buffer.seek(0)\n        text = TextIOWrapper(buffer, encoding, line_buffering=True)\n        text.mode = 'r'\n        return text\n    except:\n        buffer.close()\n        raise\n\n\ndef tokenize(readline):\n    \"\"\"\n    The tokenize() generator requires one argument, readline, which\n    must be a callable object which provides the same interface as the\n    readline() method of built-in file objects.  Each call to the function\n    should return one line of input as bytes.  Alternatively, readline\n    can be a callable function terminating with StopIteration:\n        readline = open(myfile, 'rb').__next__  # Example of alternate readline\n\n    The generator produces 5-tuples with these members: the token type; the\n    token string; a 2-tuple (srow, scol) of ints specifying the row and\n    column where the token begins in the source; a 2-tuple (erow, ecol) of\n    ints specifying the row and column where the token ends in the source;\n    and the line on which the token was found.  The line passed is the\n    physical line.\n\n    The first token sequence will always be an ENCODING token\n    which tells you which encoding was used to decode the bytes stream.\n    \"\"\"\n    encoding, consumed = detect_encoding(readline)\n    empty = _itertools.repeat(b\"\")\n    rl_gen = _itertools.chain(consumed, iter(readline, b\"\"), empty)\n    return _tokenize(rl_gen.__next__, encoding)\n\n\ndef _tokenize(readline, encoding):\n    lnum = parenlev = continued = 0\n    numchars = '0123456789'\n    contstr, needcont = '', 0\n    contline = None\n    indents = [0]\n\n    if encoding is not None:\n        if encoding == \"utf-8-sig\":\n            # BOM will already have been stripped.\n            encoding = \"utf-8\"\n        yield TokenInfo(ENCODING, encoding, (0, 0), (0, 0), '')\n    last_line = b''\n    line = b''\n    while True:                                # loop over lines in stream\n        try:\n            # We capture the value of the line variable here because\n            # readline uses the empty string '' to signal end of input,\n            # hence `line` itself will always be overwritten at the end\n            # of this loop.\n            last_line = line\n            line = readline()\n        except StopIteration:\n            line = b''\n\n        if encoding is not None:\n            line = line.decode(encoding)\n        lnum += 1\n        pos, max = 0, len(line)\n\n        if contstr:                            # continued string\n            if not line:\n                raise TokenError(\"EOF in multi-line string\", strstart)\n            endmatch = endprog.match(line)\n            if endmatch:\n                pos = end = endmatch.end(0)\n                yield TokenInfo(STRING, contstr + line[:end],\n                       strstart, (lnum, end), contline + line)\n                contstr, needcont = '', 0\n                contline = None\n            elif needcont and line[-2:] != '\\\\\\n' and line[-3:] != '\\\\\\r\\n':\n                yield TokenInfo(ERRORTOKEN, contstr + line,\n                           strstart, (lnum, len(line)), contline)\n                contstr = ''\n                contline = None\n                continue\n            else:\n                contstr = contstr + line\n                contline = contline + line\n                continue\n\n        elif parenlev == 0 and not continued:  # new statement\n            if not line: break\n            column = 0\n            while pos < max:                   # measure leading whitespace\n                if line[pos] == ' ':\n                    column += 1\n                elif line[pos] == '\\t':\n                    column = (column//tabsize + 1)*tabsize\n                elif line[pos] == '\\f':\n                    column = 0\n                else:\n                    break\n                pos += 1\n            if pos == max:\n                break\n\n            if line[pos] in '#\\r\\n':           # skip comments or blank lines\n                if line[pos] == '#':\n                    comment_token = line[pos:].rstrip('\\r\\n')\n                    yield TokenInfo(COMMENT, comment_token,\n                           (lnum, pos), (lnum, pos + len(comment_token)), line)\n                    pos += len(comment_token)\n\n                yield TokenInfo(NL, line[pos:],\n                           (lnum, pos), (lnum, len(line)), line)\n                continue\n\n            if column > indents[-1]:           # count indents or dedents\n                indents.append(column)\n                yield TokenInfo(INDENT, line[:pos], (lnum, 0), (lnum, pos), line)\n            while column < indents[-1]:\n                if column not in indents:\n                    raise IndentationError(\n                        \"unindent does not match any outer indentation level\",\n                        (\"<tokenize>\", lnum, pos, line))\n                indents = indents[:-1]\n\n                yield TokenInfo(DEDENT, '', (lnum, pos), (lnum, pos), line)\n\n        else:                                  # continued statement\n            if not line:\n                raise TokenError(\"EOF in multi-line statement\", (lnum, 0))\n            continued = 0\n\n        while pos < max:\n            pseudomatch = _compile(PseudoToken).match(line, pos)\n            if pseudomatch:                                # scan for tokens\n                start, end = pseudomatch.span(1)\n                spos, epos, pos = (lnum, start), (lnum, end), end\n                if start == end:\n                    continue\n                token, initial = line[start:end], line[start]\n\n                if (initial in numchars or                 # ordinary number\n                    (initial == '.' and token != '.' and token != '...')):\n                    yield TokenInfo(NUMBER, token, spos, epos, line)\n                elif initial in '\\r\\n':\n                    if parenlev > 0:\n                        yield TokenInfo(NL, token, spos, epos, line)\n                    else:\n                        yield TokenInfo(NEWLINE, token, spos, epos, line)\n\n                elif initial == '#':\n                    assert not token.endswith(\"\\n\")\n                    yield TokenInfo(COMMENT, token, spos, epos, line)\n\n                elif token in triple_quoted:\n                    endprog = _compile(endpats[token])\n                    endmatch = endprog.match(line, pos)\n                    if endmatch:                           # all on one line\n                        pos = endmatch.end(0)\n                        token = line[start:pos]\n                        yield TokenInfo(STRING, token, spos, (lnum, pos), line)\n                    else:\n                        strstart = (lnum, start)           # multiple lines\n                        contstr = line[start:]\n                        contline = line\n                        break\n\n                # Check up to the first 3 chars of the token to see if\n                #  they're in the single_quoted set. If so, they start\n                #  a string.\n                # We're using the first 3, because we're looking for\n                #  \"rb'\" (for example) at the start of the token. If\n                #  we switch to longer prefixes, this needs to be\n                #  adjusted.\n                # Note that initial == token[:1].\n                # Also note that single quote checking must come after\n                #  triple quote checking (above).\n                elif (initial in single_quoted or\n                      token[:2] in single_quoted or\n                      token[:3] in single_quoted):\n                    if token[-1] == '\\n':                  # continued string\n                        strstart = (lnum, start)\n                        # Again, using the first 3 chars of the\n                        #  token. This is looking for the matching end\n                        #  regex for the correct type of quote\n                        #  character. So it's really looking for\n                        #  endpats[\"'\"] or endpats['\"'], by trying to\n                        #  skip string prefix characters, if any.\n                        endprog = _compile(endpats.get(initial) or\n                                           endpats.get(token[1]) or\n                                           endpats.get(token[2]))\n                        contstr, needcont = line[start:], 1\n                        contline = line\n                        break\n                    else:                                  # ordinary string\n                        yield TokenInfo(STRING, token, spos, epos, line)\n\n                elif initial.isidentifier():               # ordinary name\n                    yield TokenInfo(NAME, token, spos, epos, line)\n                elif initial == '\\\\':                      # continued stmt\n                    continued = 1\n                else:\n                    if initial in '([{':\n                        parenlev += 1\n                    elif initial in ')]}':\n                        parenlev -= 1\n                    yield TokenInfo(OP, token, spos, epos, line)\n            else:\n                yield TokenInfo(ERRORTOKEN, line[pos],\n                           (lnum, pos), (lnum, pos+1), line)\n                pos += 1\n\n    # Add an implicit NEWLINE if the input doesn't end in one\n    if last_line and last_line[-1] not in '\\r\\n':\n        yield TokenInfo(NEWLINE, '', (lnum - 1, len(last_line)), (lnum - 1, len(last_line) + 1), '')\n    for indent in indents[1:]:                 # pop remaining indent levels\n        yield TokenInfo(DEDENT, '', (lnum, 0), (lnum, 0), '')\n    yield TokenInfo(ENDMARKER, '', (lnum, 0), (lnum, 0), '')\n\n\ndef generate_tokens(readline):\n    \"\"\"Tokenize a source reading Python code as unicode strings.\n\n    This has the same API as tokenize(), except that it expects the *readline*\n    callable to return str objects instead of bytes.\n    \"\"\"\n    return _tokenize(readline, None)\n\ndef main():\n    import argparse\n\n    # Helper error handling routines\n    def perror(message):\n        sys.stderr.write(message)\n        sys.stderr.write('\\n')\n\n    def error(message, filename=None, location=None):\n        if location:\n            args = (filename,) + location + (message,)\n            perror(\"%s:%d:%d: error: %s\" % args)\n        elif filename:\n            perror(\"%s: error: %s\" % (filename, message))\n        else:\n            perror(\"error: %s\" % message)\n        sys.exit(1)\n\n    # Parse the arguments and options\n    parser = argparse.ArgumentParser(prog='python -m tokenize')\n    parser.add_argument(dest='filename', nargs='?',\n                        metavar='filename.py',\n                        help='the file to tokenize; defaults to stdin')\n    parser.add_argument('-e', '--exact', dest='exact', action='store_true',\n                        help='display token names using the exact type')\n    args = parser.parse_args()\n\n    try:\n        # Tokenize the input\n        if args.filename:\n            filename = args.filename\n            with _builtin_open(filename, 'rb') as f:\n                tokens = list(tokenize(f.readline))\n        else:\n            filename = \"<stdin>\"\n            tokens = _tokenize(sys.stdin.readline, None)\n\n        # Output the tokenization\n        for token in tokens:\n            token_type = token.type\n            if args.exact:\n                token_type = token.exact_type\n            token_range = \"%d,%d-%d,%d:\" % (token.start + token.end)\n            print(\"%-20s%-15s%-15r\" %\n                  (token_range, tok_name[token_type], token.string))\n    except IndentationError as err:\n        line, column = err.args[1][1:3]\n        error(err.args[0], filename, (line, column))\n    except TokenError as err:\n        line, column = err.args[1]\n        error(err.args[0], filename, (line, column))\n    except SyntaxError as err:\n        error(err, filename)\n    except OSError as err:\n        error(err)\n    except KeyboardInterrupt:\n        print(\"interrupted\\n\")\n    except Exception as err:\n        perror(\"unexpected error: %s\" % err)\n        raise\n\nif __name__ == \"__main__\":\n    main()\n", 682], "/usr/lib/python3.8/codecs.py": ["\"\"\" codecs -- Python Codec Registry, API and helpers.\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.\n\n\"\"\"\n\nimport builtins\nimport sys\n\n### Registry and builtin stateless codec functions\n\ntry:\n    from _codecs import *\nexcept ImportError as why:\n    raise SystemError('Failed to load the builtin codecs: %s' % why)\n\n__all__ = [\"register\", \"lookup\", \"open\", \"EncodedFile\", \"BOM\", \"BOM_BE\",\n           \"BOM_LE\", \"BOM32_BE\", \"BOM32_LE\", \"BOM64_BE\", \"BOM64_LE\",\n           \"BOM_UTF8\", \"BOM_UTF16\", \"BOM_UTF16_LE\", \"BOM_UTF16_BE\",\n           \"BOM_UTF32\", \"BOM_UTF32_LE\", \"BOM_UTF32_BE\",\n           \"CodecInfo\", \"Codec\", \"IncrementalEncoder\", \"IncrementalDecoder\",\n           \"StreamReader\", \"StreamWriter\",\n           \"StreamReaderWriter\", \"StreamRecoder\",\n           \"getencoder\", \"getdecoder\", \"getincrementalencoder\",\n           \"getincrementaldecoder\", \"getreader\", \"getwriter\",\n           \"encode\", \"decode\", \"iterencode\", \"iterdecode\",\n           \"strict_errors\", \"ignore_errors\", \"replace_errors\",\n           \"xmlcharrefreplace_errors\",\n           \"backslashreplace_errors\", \"namereplace_errors\",\n           \"register_error\", \"lookup_error\"]\n\n### Constants\n\n#\n# Byte Order Mark (BOM = ZERO WIDTH NO-BREAK SPACE = U+FEFF)\n# and its possible byte string values\n# for UTF8/UTF16/UTF32 output and little/big endian machines\n#\n\n# UTF-8\nBOM_UTF8 = b'\\xef\\xbb\\xbf'\n\n# UTF-16, little endian\nBOM_LE = BOM_UTF16_LE = b'\\xff\\xfe'\n\n# UTF-16, big endian\nBOM_BE = BOM_UTF16_BE = b'\\xfe\\xff'\n\n# UTF-32, little endian\nBOM_UTF32_LE = b'\\xff\\xfe\\x00\\x00'\n\n# UTF-32, big endian\nBOM_UTF32_BE = b'\\x00\\x00\\xfe\\xff'\n\nif sys.byteorder == 'little':\n\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_LE\n\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_LE\n\nelse:\n\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_BE\n\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_BE\n\n# Old broken names (don't use in new code)\nBOM32_LE = BOM_UTF16_LE\nBOM32_BE = BOM_UTF16_BE\nBOM64_LE = BOM_UTF32_LE\nBOM64_BE = BOM_UTF32_BE\n\n\n### Codec base classes (defining the API)\n\nclass CodecInfo(tuple):\n    \"\"\"Codec details when looking up the codec registry\"\"\"\n\n    # Private API to allow Python 3.4 to blacklist the known non-Unicode\n    # codecs in the standard library. A more general mechanism to\n    # reliably distinguish test encodings from other codecs will hopefully\n    # be defined for Python 3.5\n    #\n    # See http://bugs.python.org/issue19619\n    _is_text_encoding = True # Assume codecs are text encodings by default\n\n    def __new__(cls, encode, decode, streamreader=None, streamwriter=None,\n        incrementalencoder=None, incrementaldecoder=None, name=None,\n        *, _is_text_encoding=None):\n        self = tuple.__new__(cls, (encode, decode, streamreader, streamwriter))\n        self.name = name\n        self.encode = encode\n        self.decode = decode\n        self.incrementalencoder = incrementalencoder\n        self.incrementaldecoder = incrementaldecoder\n        self.streamwriter = streamwriter\n        self.streamreader = streamreader\n        if _is_text_encoding is not None:\n            self._is_text_encoding = _is_text_encoding\n        return self\n\n    def __repr__(self):\n        return \"<%s.%s object for encoding %s at %#x>\" % \\\n                (self.__class__.__module__, self.__class__.__qualname__,\n                 self.name, id(self))\n\nclass Codec:\n\n    \"\"\" Defines the interface for stateless encoders/decoders.\n\n        The .encode()/.decode() methods may use different error\n        handling schemes by providing the errors argument. These\n        string values are predefined:\n\n         'strict' - raise a ValueError error (or a subclass)\n         'ignore' - ignore the character and continue with the next\n         'replace' - replace with a suitable replacement character;\n                    Python will use the official U+FFFD REPLACEMENT\n                    CHARACTER for the builtin Unicode codecs on\n                    decoding and '?' on encoding.\n         'surrogateescape' - replace with private code points U+DCnn.\n         'xmlcharrefreplace' - Replace with the appropriate XML\n                               character reference (only for encoding).\n         'backslashreplace'  - Replace with backslashed escape sequences.\n         'namereplace'       - Replace with \\\\N{...} escape sequences\n                               (only for encoding).\n\n        The set of allowed values can be extended via register_error.\n\n    \"\"\"\n    def encode(self, input, errors='strict'):\n\n        \"\"\" Encodes the object input and returns a tuple (output\n            object, length consumed).\n\n            errors defines the error handling to apply. It defaults to\n            'strict' handling.\n\n            The method may not store state in the Codec instance. Use\n            StreamWriter for codecs which have to keep state in order to\n            make encoding efficient.\n\n            The encoder must be able to handle zero length input and\n            return an empty object of the output object type in this\n            situation.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def decode(self, input, errors='strict'):\n\n        \"\"\" Decodes the object input and returns a tuple (output\n            object, length consumed).\n\n            input must be an object which provides the bf_getreadbuf\n            buffer slot. Python strings, buffer objects and memory\n            mapped files are examples of objects providing this slot.\n\n            errors defines the error handling to apply. It defaults to\n            'strict' handling.\n\n            The method may not store state in the Codec instance. Use\n            StreamReader for codecs which have to keep state in order to\n            make decoding efficient.\n\n            The decoder must be able to handle zero length input and\n            return an empty object of the output object type in this\n            situation.\n\n        \"\"\"\n        raise NotImplementedError\n\nclass IncrementalEncoder(object):\n    \"\"\"\n    An IncrementalEncoder encodes an input in multiple steps. The input can\n    be passed piece by piece to the encode() method. The IncrementalEncoder\n    remembers the state of the encoding process between calls to encode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        \"\"\"\n        Creates an IncrementalEncoder instance.\n\n        The IncrementalEncoder may use different error handling schemes by\n        providing the errors keyword argument. See the module docstring\n        for a list of possible values.\n        \"\"\"\n        self.errors = errors\n        self.buffer = \"\"\n\n    def encode(self, input, final=False):\n        \"\"\"\n        Encodes input and returns the resulting object.\n        \"\"\"\n        raise NotImplementedError\n\n    def reset(self):\n        \"\"\"\n        Resets the encoder to the initial state.\n        \"\"\"\n\n    def getstate(self):\n        \"\"\"\n        Return the current state of the encoder.\n        \"\"\"\n        return 0\n\n    def setstate(self, state):\n        \"\"\"\n        Set the current state of the encoder. state must have been\n        returned by getstate().\n        \"\"\"\n\nclass BufferedIncrementalEncoder(IncrementalEncoder):\n    \"\"\"\n    This subclass of IncrementalEncoder can be used as the baseclass for an\n    incremental encoder if the encoder must keep some of the output in a\n    buffer between calls to encode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        IncrementalEncoder.__init__(self, errors)\n        # unencoded input that is kept between calls to encode()\n        self.buffer = \"\"\n\n    def _buffer_encode(self, input, errors, final):\n        # Overwrite this method in subclasses: It must encode input\n        # and return an (output, length consumed) tuple\n        raise NotImplementedError\n\n    def encode(self, input, final=False):\n        # encode input (taking the buffer into account)\n        data = self.buffer + input\n        (result, consumed) = self._buffer_encode(data, self.errors, final)\n        # keep unencoded input until the next call\n        self.buffer = data[consumed:]\n        return result\n\n    def reset(self):\n        IncrementalEncoder.reset(self)\n        self.buffer = \"\"\n\n    def getstate(self):\n        return self.buffer or 0\n\n    def setstate(self, state):\n        self.buffer = state or \"\"\n\nclass IncrementalDecoder(object):\n    \"\"\"\n    An IncrementalDecoder decodes an input in multiple steps. The input can\n    be passed piece by piece to the decode() method. The IncrementalDecoder\n    remembers the state of the decoding process between calls to decode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        \"\"\"\n        Create an IncrementalDecoder instance.\n\n        The IncrementalDecoder may use different error handling schemes by\n        providing the errors keyword argument. See the module docstring\n        for a list of possible values.\n        \"\"\"\n        self.errors = errors\n\n    def decode(self, input, final=False):\n        \"\"\"\n        Decode input and returns the resulting object.\n        \"\"\"\n        raise NotImplementedError\n\n    def reset(self):\n        \"\"\"\n        Reset the decoder to the initial state.\n        \"\"\"\n\n    def getstate(self):\n        \"\"\"\n        Return the current state of the decoder.\n\n        This must be a (buffered_input, additional_state_info) tuple.\n        buffered_input must be a bytes object containing bytes that\n        were passed to decode() that have not yet been converted.\n        additional_state_info must be a non-negative integer\n        representing the state of the decoder WITHOUT yet having\n        processed the contents of buffered_input.  In the initial state\n        and after reset(), getstate() must return (b\"\", 0).\n        \"\"\"\n        return (b\"\", 0)\n\n    def setstate(self, state):\n        \"\"\"\n        Set the current state of the decoder.\n\n        state must have been returned by getstate().  The effect of\n        setstate((b\"\", 0)) must be equivalent to reset().\n        \"\"\"\n\nclass BufferedIncrementalDecoder(IncrementalDecoder):\n    \"\"\"\n    This subclass of IncrementalDecoder can be used as the baseclass for an\n    incremental decoder if the decoder must be able to handle incomplete\n    byte sequences.\n    \"\"\"\n    def __init__(self, errors='strict'):\n        IncrementalDecoder.__init__(self, errors)\n        # undecoded input that is kept between calls to decode()\n        self.buffer = b\"\"\n\n    def _buffer_decode(self, input, errors, final):\n        # Overwrite this method in subclasses: It must decode input\n        # and return an (output, length consumed) tuple\n        raise NotImplementedError\n\n    def decode(self, input, final=False):\n        # decode input (taking the buffer into account)\n        data = self.buffer + input\n        (result, consumed) = self._buffer_decode(data, self.errors, final)\n        # keep undecoded input until the next call\n        self.buffer = data[consumed:]\n        return result\n\n    def reset(self):\n        IncrementalDecoder.reset(self)\n        self.buffer = b\"\"\n\n    def getstate(self):\n        # additional state info is always 0\n        return (self.buffer, 0)\n\n    def setstate(self, state):\n        # ignore additional state info\n        self.buffer = state[0]\n\n#\n# The StreamWriter and StreamReader class provide generic working\n# interfaces which can be used to implement new encoding submodules\n# very easily. See encodings/utf_8.py for an example on how this is\n# done.\n#\n\nclass StreamWriter(Codec):\n\n    def __init__(self, stream, errors='strict'):\n\n        \"\"\" Creates a StreamWriter instance.\n\n            stream must be a file-like object open for writing.\n\n            The StreamWriter may use different error handling\n            schemes by providing the errors keyword argument. These\n            parameters are predefined:\n\n             'strict' - raise a ValueError (or a subclass)\n             'ignore' - ignore the character and continue with the next\n             'replace'- replace with a suitable replacement character\n             'xmlcharrefreplace' - Replace with the appropriate XML\n                                   character reference.\n             'backslashreplace'  - Replace with backslashed escape\n                                   sequences.\n             'namereplace'       - Replace with \\\\N{...} escape sequences.\n\n            The set of allowed parameter values can be extended via\n            register_error.\n        \"\"\"\n        self.stream = stream\n        self.errors = errors\n\n    def write(self, object):\n\n        \"\"\" Writes the object's contents encoded to self.stream.\n        \"\"\"\n        data, consumed = self.encode(object, self.errors)\n        self.stream.write(data)\n\n    def writelines(self, list):\n\n        \"\"\" Writes the concatenated list of strings to the stream\n            using .write().\n        \"\"\"\n        self.write(''.join(list))\n\n    def reset(self):\n\n        \"\"\" Flushes and resets the codec buffers used for keeping state.\n\n            Calling this method should ensure that the data on the\n            output is put into a clean state, that allows appending\n            of new fresh data without having to rescan the whole\n            stream to recover state.\n\n        \"\"\"\n        pass\n\n    def seek(self, offset, whence=0):\n        self.stream.seek(offset, whence)\n        if whence == 0 and offset == 0:\n            self.reset()\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n###\n\nclass StreamReader(Codec):\n\n    charbuffertype = str\n\n    def __init__(self, stream, errors='strict'):\n\n        \"\"\" Creates a StreamReader instance.\n\n            stream must be a file-like object open for reading.\n\n            The StreamReader may use different error handling\n            schemes by providing the errors keyword argument. These\n            parameters are predefined:\n\n             'strict' - raise a ValueError (or a subclass)\n             'ignore' - ignore the character and continue with the next\n             'replace'- replace with a suitable replacement character\n             'backslashreplace' - Replace with backslashed escape sequences;\n\n            The set of allowed parameter values can be extended via\n            register_error.\n        \"\"\"\n        self.stream = stream\n        self.errors = errors\n        self.bytebuffer = b\"\"\n        self._empty_charbuffer = self.charbuffertype()\n        self.charbuffer = self._empty_charbuffer\n        self.linebuffer = None\n\n    def decode(self, input, errors='strict'):\n        raise NotImplementedError\n\n    def read(self, size=-1, chars=-1, firstline=False):\n\n        \"\"\" Decodes data from the stream self.stream and returns the\n            resulting object.\n\n            chars indicates the number of decoded code points or bytes to\n            return. read() will never return more data than requested,\n            but it might return less, if there is not enough available.\n\n            size indicates the approximate maximum number of decoded\n            bytes or code points to read for decoding. The decoder\n            can modify this setting as appropriate. The default value\n            -1 indicates to read and decode as much as possible.  size\n            is intended to prevent having to decode huge files in one\n            step.\n\n            If firstline is true, and a UnicodeDecodeError happens\n            after the first line terminator in the input only the first line\n            will be returned, the rest of the input will be kept until the\n            next call to read().\n\n            The method should use a greedy read strategy, meaning that\n            it should read as much data as is allowed within the\n            definition of the encoding and the given size, e.g.  if\n            optional encoding endings or state markers are available\n            on the stream, these should be read too.\n        \"\"\"\n        # If we have lines cached, first merge them back into characters\n        if self.linebuffer:\n            self.charbuffer = self._empty_charbuffer.join(self.linebuffer)\n            self.linebuffer = None\n\n        if chars < 0:\n            # For compatibility with other read() methods that take a\n            # single argument\n            chars = size\n\n        # read until we get the required number of characters (if available)\n        while True:\n            # can the request be satisfied from the character buffer?\n            if chars >= 0:\n                if len(self.charbuffer) >= chars:\n                    break\n            # we need more data\n            if size < 0:\n                newdata = self.stream.read()\n            else:\n                newdata = self.stream.read(size)\n            # decode bytes (those remaining from the last call included)\n            data = self.bytebuffer + newdata\n            if not data:\n                break\n            try:\n                newchars, decodedbytes = self.decode(data, self.errors)\n            except UnicodeDecodeError as exc:\n                if firstline:\n                    newchars, decodedbytes = \\\n                        self.decode(data[:exc.start], self.errors)\n                    lines = newchars.splitlines(keepends=True)\n                    if len(lines)<=1:\n                        raise\n                else:\n                    raise\n            # keep undecoded bytes until the next call\n            self.bytebuffer = data[decodedbytes:]\n            # put new characters in the character buffer\n            self.charbuffer += newchars\n            # there was no data available\n            if not newdata:\n                break\n        if chars < 0:\n            # Return everything we've got\n            result = self.charbuffer\n            self.charbuffer = self._empty_charbuffer\n        else:\n            # Return the first chars characters\n            result = self.charbuffer[:chars]\n            self.charbuffer = self.charbuffer[chars:]\n        return result\n\n    def readline(self, size=None, keepends=True):\n\n        \"\"\" Read one line from the input stream and return the\n            decoded data.\n\n            size, if given, is passed as size argument to the\n            read() method.\n\n        \"\"\"\n        # If we have lines cached from an earlier read, return\n        # them unconditionally\n        if self.linebuffer:\n            line = self.linebuffer[0]\n            del self.linebuffer[0]\n            if len(self.linebuffer) == 1:\n                # revert to charbuffer mode; we might need more data\n                # next time\n                self.charbuffer = self.linebuffer[0]\n                self.linebuffer = None\n            if not keepends:\n                line = line.splitlines(keepends=False)[0]\n            return line\n\n        readsize = size or 72\n        line = self._empty_charbuffer\n        # If size is given, we call read() only once\n        while True:\n            data = self.read(readsize, firstline=True)\n            if data:\n                # If we're at a \"\\r\" read one extra character (which might\n                # be a \"\\n\") to get a proper line ending. If the stream is\n                # temporarily exhausted we return the wrong line ending.\n                if (isinstance(data, str) and data.endswith(\"\\r\")) or \\\n                   (isinstance(data, bytes) and data.endswith(b\"\\r\")):\n                    data += self.read(size=1, chars=1)\n\n            line += data\n            lines = line.splitlines(keepends=True)\n            if lines:\n                if len(lines) > 1:\n                    # More than one line result; the first line is a full line\n                    # to return\n                    line = lines[0]\n                    del lines[0]\n                    if len(lines) > 1:\n                        # cache the remaining lines\n                        lines[-1] += self.charbuffer\n                        self.linebuffer = lines\n                        self.charbuffer = None\n                    else:\n                        # only one remaining line, put it back into charbuffer\n                        self.charbuffer = lines[0] + self.charbuffer\n                    if not keepends:\n                        line = line.splitlines(keepends=False)[0]\n                    break\n                line0withend = lines[0]\n                line0withoutend = lines[0].splitlines(keepends=False)[0]\n                if line0withend != line0withoutend: # We really have a line end\n                    # Put the rest back together and keep it until the next call\n                    self.charbuffer = self._empty_charbuffer.join(lines[1:]) + \\\n                                      self.charbuffer\n                    if keepends:\n                        line = line0withend\n                    else:\n                        line = line0withoutend\n                    break\n            # we didn't get anything or this was our only try\n            if not data or size is not None:\n                if line and not keepends:\n                    line = line.splitlines(keepends=False)[0]\n                break\n            if readsize < 8000:\n                readsize *= 2\n        return line\n\n    def readlines(self, sizehint=None, keepends=True):\n\n        \"\"\" Read all lines available on the input stream\n            and return them as a list.\n\n            Line breaks are implemented using the codec's decoder\n            method and are included in the list entries.\n\n            sizehint, if given, is ignored since there is no efficient\n            way to finding the true end-of-line.\n\n        \"\"\"\n        data = self.read()\n        return data.splitlines(keepends)\n\n    def reset(self):\n\n        \"\"\" Resets the codec buffers used for keeping state.\n\n            Note that no stream repositioning should take place.\n            This method is primarily intended to be able to recover\n            from decoding errors.\n\n        \"\"\"\n        self.bytebuffer = b\"\"\n        self.charbuffer = self._empty_charbuffer\n        self.linebuffer = None\n\n    def seek(self, offset, whence=0):\n        \"\"\" Set the input stream's current position.\n\n            Resets the codec buffers used for keeping state.\n        \"\"\"\n        self.stream.seek(offset, whence)\n        self.reset()\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        line = self.readline()\n        if line:\n            return line\n        raise StopIteration\n\n    def __iter__(self):\n        return self\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n###\n\nclass StreamReaderWriter:\n\n    \"\"\" StreamReaderWriter instances allow wrapping streams which\n        work in both read and write modes.\n\n        The design is such that one can use the factory functions\n        returned by the codec.lookup() function to construct the\n        instance.\n\n    \"\"\"\n    # Optional attributes set by the file wrappers below\n    encoding = 'unknown'\n\n    def __init__(self, stream, Reader, Writer, errors='strict'):\n\n        \"\"\" Creates a StreamReaderWriter instance.\n\n            stream must be a Stream-like object.\n\n            Reader, Writer must be factory functions or classes\n            providing the StreamReader, StreamWriter interface resp.\n\n            Error handling is done in the same way as defined for the\n            StreamWriter/Readers.\n\n        \"\"\"\n        self.stream = stream\n        self.reader = Reader(stream, errors)\n        self.writer = Writer(stream, errors)\n        self.errors = errors\n\n    def read(self, size=-1):\n\n        return self.reader.read(size)\n\n    def readline(self, size=None):\n\n        return self.reader.readline(size)\n\n    def readlines(self, sizehint=None):\n\n        return self.reader.readlines(sizehint)\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        return next(self.reader)\n\n    def __iter__(self):\n        return self\n\n    def write(self, data):\n\n        return self.writer.write(data)\n\n    def writelines(self, list):\n\n        return self.writer.writelines(list)\n\n    def reset(self):\n\n        self.reader.reset()\n        self.writer.reset()\n\n    def seek(self, offset, whence=0):\n        self.stream.seek(offset, whence)\n        self.reader.reset()\n        if whence == 0 and offset == 0:\n            self.writer.reset()\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    # these are needed to make \"with StreamReaderWriter(...)\" work properly\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n###\n\nclass StreamRecoder:\n\n    \"\"\" StreamRecoder instances translate data from one encoding to another.\n\n        They use the complete set of APIs returned by the\n        codecs.lookup() function to implement their task.\n\n        Data written to the StreamRecoder is first decoded into an\n        intermediate format (depending on the \"decode\" codec) and then\n        written to the underlying stream using an instance of the provided\n        Writer class.\n\n        In the other direction, data is read from the underlying stream using\n        a Reader instance and then encoded and returned to the caller.\n\n    \"\"\"\n    # Optional attributes set by the file wrappers below\n    data_encoding = 'unknown'\n    file_encoding = 'unknown'\n\n    def __init__(self, stream, encode, decode, Reader, Writer,\n                 errors='strict'):\n\n        \"\"\" Creates a StreamRecoder instance which implements a two-way\n            conversion: encode and decode work on the frontend (the\n            data visible to .read() and .write()) while Reader and Writer\n            work on the backend (the data in stream).\n\n            You can use these objects to do transparent\n            transcodings from e.g. latin-1 to utf-8 and back.\n\n            stream must be a file-like object.\n\n            encode and decode must adhere to the Codec interface; Reader and\n            Writer must be factory functions or classes providing the\n            StreamReader and StreamWriter interfaces resp.\n\n            Error handling is done in the same way as defined for the\n            StreamWriter/Readers.\n\n        \"\"\"\n        self.stream = stream\n        self.encode = encode\n        self.decode = decode\n        self.reader = Reader(stream, errors)\n        self.writer = Writer(stream, errors)\n        self.errors = errors\n\n    def read(self, size=-1):\n\n        data = self.reader.read(size)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def readline(self, size=None):\n\n        if size is None:\n            data = self.reader.readline()\n        else:\n            data = self.reader.readline(size)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def readlines(self, sizehint=None):\n\n        data = self.reader.read()\n        data, bytesencoded = self.encode(data, self.errors)\n        return data.splitlines(keepends=True)\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        data = next(self.reader)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def __iter__(self):\n        return self\n\n    def write(self, data):\n\n        data, bytesdecoded = self.decode(data, self.errors)\n        return self.writer.write(data)\n\n    def writelines(self, list):\n\n        data = b''.join(list)\n        data, bytesdecoded = self.decode(data, self.errors)\n        return self.writer.write(data)\n\n    def reset(self):\n\n        self.reader.reset()\n        self.writer.reset()\n\n    def seek(self, offset, whence=0):\n        # Seeks must be propagated to both the readers and writers\n        # as they might need to reset their internal buffers.\n        self.reader.seek(offset, whence)\n        self.writer.seek(offset, whence)\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n### Shortcuts\n\ndef open(filename, mode='r', encoding=None, errors='strict', buffering=-1):\n\n    \"\"\" Open an encoded file using the given mode and return\n        a wrapped version providing transparent encoding/decoding.\n\n        Note: The wrapped version will only accept the object format\n        defined by the codecs, i.e. Unicode objects for most builtin\n        codecs. Output is also codec dependent and will usually be\n        Unicode as well.\n\n        Underlying encoded files are always opened in binary mode.\n        The default file mode is 'r', meaning to open the file in read mode.\n\n        encoding specifies the encoding which is to be used for the\n        file.\n\n        errors may be given to define the error handling. It defaults\n        to 'strict' which causes ValueErrors to be raised in case an\n        encoding error occurs.\n\n        buffering has the same meaning as for the builtin open() API.\n        It defaults to -1 which means that the default buffer size will\n        be used.\n\n        The returned wrapped file object provides an extra attribute\n        .encoding which allows querying the used encoding. This\n        attribute is only available if an encoding was specified as\n        parameter.\n\n    \"\"\"\n    if encoding is not None and \\\n       'b' not in mode:\n        # Force opening of the file in binary mode\n        mode = mode + 'b'\n    file = builtins.open(filename, mode, buffering)\n    if encoding is None:\n        return file\n\n    try:\n        info = lookup(encoding)\n        srw = StreamReaderWriter(file, info.streamreader, info.streamwriter, errors)\n        # Add attributes to simplify introspection\n        srw.encoding = encoding\n        return srw\n    except:\n        file.close()\n        raise\n\ndef EncodedFile(file, data_encoding, file_encoding=None, errors='strict'):\n\n    \"\"\" Return a wrapped version of file which provides transparent\n        encoding translation.\n\n        Data written to the wrapped file is decoded according\n        to the given data_encoding and then encoded to the underlying\n        file using file_encoding. The intermediate data type\n        will usually be Unicode but depends on the specified codecs.\n\n        Bytes read from the file are decoded using file_encoding and then\n        passed back to the caller encoded using data_encoding.\n\n        If file_encoding is not given, it defaults to data_encoding.\n\n        errors may be given to define the error handling. It defaults\n        to 'strict' which causes ValueErrors to be raised in case an\n        encoding error occurs.\n\n        The returned wrapped file object provides two extra attributes\n        .data_encoding and .file_encoding which reflect the given\n        parameters of the same name. The attributes can be used for\n        introspection by Python programs.\n\n    \"\"\"\n    if file_encoding is None:\n        file_encoding = data_encoding\n    data_info = lookup(data_encoding)\n    file_info = lookup(file_encoding)\n    sr = StreamRecoder(file, data_info.encode, data_info.decode,\n                       file_info.streamreader, file_info.streamwriter, errors)\n    # Add attributes to simplify introspection\n    sr.data_encoding = data_encoding\n    sr.file_encoding = file_encoding\n    return sr\n\n### Helpers for codec lookup\n\ndef getencoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its encoder function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).encode\n\ndef getdecoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its decoder function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).decode\n\ndef getincrementalencoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalEncoder class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found\n        or the codecs doesn't provide an incremental encoder.\n\n    \"\"\"\n    encoder = lookup(encoding).incrementalencoder\n    if encoder is None:\n        raise LookupError(encoding)\n    return encoder\n\ndef getincrementaldecoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalDecoder class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found\n        or the codecs doesn't provide an incremental decoder.\n\n    \"\"\"\n    decoder = lookup(encoding).incrementaldecoder\n    if decoder is None:\n        raise LookupError(encoding)\n    return decoder\n\ndef getreader(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamReader class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).streamreader\n\ndef getwriter(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamWriter class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).streamwriter\n\ndef iterencode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Encoding iterator.\n\n    Encodes the input strings from the iterator using an IncrementalEncoder.\n\n    errors and kwargs are passed through to the IncrementalEncoder\n    constructor.\n    \"\"\"\n    encoder = getincrementalencoder(encoding)(errors, **kwargs)\n    for input in iterator:\n        output = encoder.encode(input)\n        if output:\n            yield output\n    output = encoder.encode(\"\", True)\n    if output:\n        yield output\n\ndef iterdecode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Decoding iterator.\n\n    Decodes the input strings from the iterator using an IncrementalDecoder.\n\n    errors and kwargs are passed through to the IncrementalDecoder\n    constructor.\n    \"\"\"\n    decoder = getincrementaldecoder(encoding)(errors, **kwargs)\n    for input in iterator:\n        output = decoder.decode(input)\n        if output:\n            yield output\n    output = decoder.decode(b\"\", True)\n    if output:\n        yield output\n\n### Helpers for charmap-based codecs\n\ndef make_identity_dict(rng):\n\n    \"\"\" make_identity_dict(rng) -> dict\n\n        Return a dictionary where elements of the rng sequence are\n        mapped to themselves.\n\n    \"\"\"\n    return {i:i for i in rng}\n\ndef make_encoding_map(decoding_map):\n\n    \"\"\" Creates an encoding map from a decoding map.\n\n        If a target mapping in the decoding map occurs multiple\n        times, then that target is mapped to None (undefined mapping),\n        causing an exception when encountered by the charmap codec\n        during translation.\n\n        One example where this happens is cp875.py which decodes\n        multiple character to \\\\u001a.\n\n    \"\"\"\n    m = {}\n    for k,v in decoding_map.items():\n        if not v in m:\n            m[v] = k\n        else:\n            m[v] = None\n    return m\n\n### error handlers\n\ntry:\n    strict_errors = lookup_error(\"strict\")\n    ignore_errors = lookup_error(\"ignore\")\n    replace_errors = lookup_error(\"replace\")\n    xmlcharrefreplace_errors = lookup_error(\"xmlcharrefreplace\")\n    backslashreplace_errors = lookup_error(\"backslashreplace\")\n    namereplace_errors = lookup_error(\"namereplace\")\nexcept LookupError:\n    # In --disable-unicode builds, these error handler are missing\n    strict_errors = None\n    ignore_errors = None\n    replace_errors = None\n    xmlcharrefreplace_errors = None\n    backslashreplace_errors = None\n    namereplace_errors = None\n\n# Tell modulefinder that using codecs probably needs the encodings\n# package\n_false = 0\nif _false:\n    import encodings\n\n### Tests\n\nif __name__ == '__main__':\n\n    # Make stdout translate Latin-1 output into UTF-8 output\n    sys.stdout = EncodedFile(sys.stdout, 'latin-1', 'utf-8')\n\n    # Have stdin translate Latin-1 input into UTF-8 input\n    sys.stdin = EncodedFile(sys.stdin, 'utf-8', 'latin-1')\n", 1126], "/usr/lib/python3.8/linecache.py": ["\"\"\"Cache lines from Python source files.\n\nThis is intended to read lines from modules imported -- hence if a filename\nis not found, it will look down the module search path for a file by\nthat name.\n\"\"\"\n\nimport functools\nimport sys\nimport os\nimport tokenize\n\n__all__ = [\"getline\", \"clearcache\", \"checkcache\"]\n\ndef getline(filename, lineno, module_globals=None):\n    lines = getlines(filename, module_globals)\n    if 1 <= lineno <= len(lines):\n        return lines[lineno-1]\n    else:\n        return ''\n\n\n# The cache\n\n# The cache. Maps filenames to either a thunk which will provide source code,\n# or a tuple (size, mtime, lines, fullname) once loaded.\ncache = {}\n\n\ndef clearcache():\n    \"\"\"Clear the cache entirely.\"\"\"\n\n    global cache\n    cache = {}\n\n\ndef getlines(filename, module_globals=None):\n    \"\"\"Get the lines for a Python source file from the cache.\n    Update the cache if it doesn't contain an entry for this file already.\"\"\"\n\n    if filename in cache:\n        entry = cache[filename]\n        if len(entry) != 1:\n            return cache[filename][2]\n\n    try:\n        return updatecache(filename, module_globals)\n    except MemoryError:\n        clearcache()\n        return []\n\n\ndef checkcache(filename=None):\n    \"\"\"Discard cache entries that are out of date.\n    (This is not checked upon each call!)\"\"\"\n\n    if filename is None:\n        filenames = list(cache.keys())\n    else:\n        if filename in cache:\n            filenames = [filename]\n        else:\n            return\n\n    for filename in filenames:\n        entry = cache[filename]\n        if len(entry) == 1:\n            # lazy cache entry, leave it lazy.\n            continue\n        size, mtime, lines, fullname = entry\n        if mtime is None:\n            continue   # no-op for files loaded via a __loader__\n        try:\n            stat = os.stat(fullname)\n        except OSError:\n            cache.pop(filename, None)\n            continue\n        if size != stat.st_size or mtime != stat.st_mtime:\n            cache.pop(filename, None)\n\n\ndef updatecache(filename, module_globals=None):\n    \"\"\"Update a cache entry and return its list of lines.\n    If something's wrong, print a message, discard the cache entry,\n    and return an empty list.\"\"\"\n\n    if filename in cache:\n        if len(cache[filename]) != 1:\n            cache.pop(filename, None)\n    if not filename or (filename.startswith('<') and filename.endswith('>')):\n        return []\n\n    fullname = filename\n    try:\n        stat = os.stat(fullname)\n    except OSError:\n        basename = filename\n\n        # Realise a lazy loader based lookup if there is one\n        # otherwise try to lookup right now.\n        if lazycache(filename, module_globals):\n            try:\n                data = cache[filename][0]()\n            except (ImportError, OSError):\n                pass\n            else:\n                if data is None:\n                    # No luck, the PEP302 loader cannot find the source\n                    # for this module.\n                    return []\n                cache[filename] = (\n                    len(data), None,\n                    [line+'\\n' for line in data.splitlines()], fullname\n                )\n                return cache[filename][2]\n\n        # Try looking through the module search path, which is only useful\n        # when handling a relative filename.\n        if os.path.isabs(filename):\n            return []\n\n        for dirname in sys.path:\n            try:\n                fullname = os.path.join(dirname, basename)\n            except (TypeError, AttributeError):\n                # Not sufficiently string-like to do anything useful with.\n                continue\n            try:\n                stat = os.stat(fullname)\n                break\n            except OSError:\n                pass\n        else:\n            return []\n    try:\n        with tokenize.open(fullname) as fp:\n            lines = fp.readlines()\n    except OSError:\n        return []\n    if lines and not lines[-1].endswith('\\n'):\n        lines[-1] += '\\n'\n    size, mtime = stat.st_size, stat.st_mtime\n    cache[filename] = size, mtime, lines, fullname\n    return lines\n\n\ndef lazycache(filename, module_globals):\n    \"\"\"Seed the cache for filename with module_globals.\n\n    The module loader will be asked for the source only when getlines is\n    called, not immediately.\n\n    If there is an entry in the cache already, it is not altered.\n\n    :return: True if a lazy load is registered in the cache,\n        otherwise False. To register such a load a module loader with a\n        get_source method must be found, the filename must be a cachable\n        filename, and the filename must not be already cached.\n    \"\"\"\n    if filename in cache:\n        if len(cache[filename]) == 1:\n            return True\n        else:\n            return False\n    if not filename or (filename.startswith('<') and filename.endswith('>')):\n        return False\n    # Try for a __loader__, if available\n    if module_globals and '__loader__' in module_globals:\n        name = module_globals.get('__name__')\n        loader = module_globals['__loader__']\n        get_source = getattr(loader, 'get_source', None)\n\n        if name and get_source:\n            get_lines = functools.partial(get_source, name)\n            cache[filename] = (get_lines,)\n            return True\n    return False\n", 177], "./models/base.py": ["#!/usr/bin/python3\n\"\"\"\nThis class will be the base of all other classes\nthe goal of it is to manage id att in all future classes\nand avoid duplicating the same code\n\"\"\"\n\nimport json\n\nclass  Base:\n    \"\"\"base class\"\"\"\n    __nb_objects = 0\n\n    def __init__(self, id=None):\n        \"\"\"add id value if not none, otherwise add 1 to nb_obj\"\"\"\n        if id != None:\n            self.id = id\n        else:\n            Base.__nb_objects += 1\n            self.id = self.__nb_objects\n\n    @staticmethod\n    def to_json_string(list_dictionaries):\n        \"\"\"\"\"\"\n        if list_dictionaries is None:\n            list_dictionaries = []\n        return json.dumps(list_dictionaries)\n\n    @classmethod\n    def save_to_file(cls, list_objs):\n        \"\"\"\"\"\"\n        file = []\n        file_name = cls.__name__ + \".json\"\n        if list_objs is not None:\n            for i in list_objs:\n                file.append(cls.to_dictionary(i))\n        with open(file_name, \"w\") as fi:\n            fi.write(cls.to_json_string(file))\n\n    @staticmethod\n    def from_json_string(json_string):\n        if json_string is None or len(json_string) == 0:\n            return []\n\n        return json.loads(json_string)\n\n    @classmethod\n    def create(cls, **dictionary):\n        if cls.__name__ is \"Rectangle\":\n            dummy = cls(1, 1)\n        if cls.__name__ is \"Square\":\n            dummy = cls(1)\n        return dummy\n\n    @classmethod\n    def load_from_file(cls):\n        file = []\n        file_name = cls.__name__ + \".json\"\n        \n", 59], "./models/rectangle.py": ["#!/usr/bin/python3\n\"\"\"\n\n\"\"\"\nfrom models.base import Base\n\nclass Rectangle(Base):\n    \"\"\"h\"\"\"\n    def __init__(self, width, height, x=0, y=0, id=None):\n        self.width = width\n        self.height = height\n        self.x = x\n        self.y = y\n        super().__init__(id)\n\n    @property\n    def width(self):\n        return self.__width\n\n    @width.setter\n    def width(self, value):\n        if type(value) is not int:\n            raise TypeError(\"width must be an integer\")\n        if value <= 0:\n            raise ValueError(\"width must be > 0\")\n        self.__width = value\n\n    @property\n    def height(self):\n        return self.__height\n\n    @height.setter\n    def height(self, value):\n        if type(value) is not int:\n            raise TypeError(\"height must be an integer\")\n        if value <= 0:\n            raise ValueError(\"height must be > 0\")\n        self.__height = value\n\n    @property\n    def x(self):\n        return self.__x\n\n    @x.setter\n    def x(self, value):\n        if type(value) is not int:\n            raise TypeError(\"x must be an integer\")\n        if value < 0:\n            raise ValueError(\"x must be >= 0\")\n        self.__x = value\n\n    @property\n    def y(self):\n        return self.__y\n\n    @y.setter\n    def y(self, value):\n        if type(value) is not int:\n            raise TypeError(\"y must be an integer\")\n        if value < 0:\n            raise ValueError(\"y must be >= 0\")\n        self.__y = value\n\n    def area(self):\n        return self.__width * self.__height\n\n    def display(self):\n        for i in range(self.__y):\n            print(\"\")\n        for i in range(self.__height):\n            for c in range(self.__x):\n                print(\" \", end=\"\")\n            for b in range(self.__width):\n                print(\"#\", end=\"\")\n            print()\n\n    def __str__(self):\n        return \"[Rectangle] ({}) {}/{} - {}/{}\".format(self.id, \n                                                       self.__x, \n                                                       self.__y, \n                                                       self.__width, \n                                                       self.__height)\n\n    def update(self, *args, **kwargs):\n        if len(args) > 0:\n            for i, arg in enumerate(args):\n                if i == 0:\n                    self.id = arg\n                if i == 1:\n                    self.width = arg\n                if i == 2:\n                    self.height = arg\n                if i == 3:\n                    self.x = arg\n                if i == 4:\n                    self.y = arg\n        else:\n            if \"id\" in kwargs:\n                self.id = kwargs[\"id\"]\n            if \"width\" in kwargs:\n                self.width = kwargs[\"width\"]\n            if \"height\" in kwargs:\n                self.height = kwargs[\"height\"]\n            if \"x\" in kwargs:\n                self.x = kwargs[\"x\"]\n            if \"y\" in kwargs:\n                self.y = kwargs[\"y\"]\n\n    def to_dictionary(self):\n        \"\"\"\"\"\"\n        dictionary = {}\n        dictionary[\"x\"] = self.x\n        dictionary[\"y\"] = self.y\n        dictionary[\"id\"] = self.id\n        dictionary[\"height\"] = self.height\n        dictionary[\"width\"] = self.width\n        return dictionary\n", 117], "/home/joshua/Holberton/holbertonschool-higher_level_programming/0x0C-python-almost_a_circle/17-main.py": ["#!/usr/bin/python3\n\"\"\" 17-main \"\"\"\nfrom models.rectangle import Rectangle\n\nif __name__ == \"__main__\":\n\n    r1 = Rectangle(3, 5, 1)\n    r1_dictionary = r1.to_dictionary()\n    r2 = Rectangle.create(**r1_dictionary)\n    print(r1)\n    print(r2)\n    print(r1 is r2)\n    print(r1 == r2)\n", 13]}, "functions": {"<module> (./models/__init__.py:1)": ["./models/__init__.py", 1], "__init__ (/usr/lib/python3.8/warnings.py:403)": ["/usr/lib/python3.8/warnings.py", 403], "read_or_stop (/usr/lib/python3.8/tokenize.py:319)": ["/usr/lib/python3.8/tokenize.py", 319], "find_cookie (/usr/lib/python3.8/tokenize.py:325)": ["/usr/lib/python3.8/tokenize.py", 325], "detect_encoding (/usr/lib/python3.8/tokenize.py:295)": ["/usr/lib/python3.8/tokenize.py", 295], "__init__ (/usr/lib/python3.8/codecs.py:260)": ["/usr/lib/python3.8/codecs.py", 260], "__init__ (/usr/lib/python3.8/codecs.py:309)": ["/usr/lib/python3.8/codecs.py", 309], "open (/usr/lib/python3.8/tokenize.py:388)": ["/usr/lib/python3.8/tokenize.py", 388], "decode (/usr/lib/python3.8/codecs.py:319)": ["/usr/lib/python3.8/codecs.py", 319], "updatecache (/usr/lib/python3.8/linecache.py:82)": ["/usr/lib/python3.8/linecache.py", 82], "getlines (/usr/lib/python3.8/linecache.py:37)": ["/usr/lib/python3.8/linecache.py", 37], "getline (/usr/lib/python3.8/linecache.py:15)": ["/usr/lib/python3.8/linecache.py", 15], "_formatwarnmsg_impl (/usr/lib/python3.8/warnings.py:35)": ["/usr/lib/python3.8/warnings.py", 35], "_formatwarnmsg (/usr/lib/python3.8/warnings.py:117)": ["/usr/lib/python3.8/warnings.py", 117], "_showwarnmsg_impl (/usr/lib/python3.8/warnings.py:20)": ["/usr/lib/python3.8/warnings.py", 20], "_showwarnmsg (/usr/lib/python3.8/warnings.py:96)": ["/usr/lib/python3.8/warnings.py", 96], "Base (./models/base.py:10)": ["./models/base.py", 10], "<module> (./models/base.py:2)": ["./models/base.py", 2], "Rectangle (./models/rectangle.py:7)": ["./models/rectangle.py", 7], "<module> (./models/rectangle.py:2)": ["./models/rectangle.py", 2], "width (./models/rectangle.py:20)": ["./models/rectangle.py", 20], "height (./models/rectangle.py:32)": ["./models/rectangle.py", 32], "x (./models/rectangle.py:44)": ["./models/rectangle.py", 44], "y (./models/rectangle.py:56)": ["./models/rectangle.py", 56], "__init__ (./models/base.py:14)": ["./models/base.py", 14], "__init__ (./models/rectangle.py:9)": ["./models/rectangle.py", 9], "x (./models/rectangle.py:40)": ["./models/rectangle.py", 40], "y (./models/rectangle.py:52)": ["./models/rectangle.py", 52], "height (./models/rectangle.py:28)": ["./models/rectangle.py", 28], "width (./models/rectangle.py:16)": ["./models/rectangle.py", 16], "to_dictionary (./models/rectangle.py:109)": ["./models/rectangle.py", 109], "create (./models/base.py:47)": ["./models/base.py", 47], "__str__ (./models/rectangle.py:77)": ["./models/rectangle.py", 77], "<module> (/home/joshua/Holberton/holbertonschool-higher_level_programming/0x0C-python-almost_a_circle/17-main.py:2)": ["/home/joshua/Holberton/holbertonschool-higher_level_programming/0x0C-python-almost_a_circle/17-main.py", 2]}}}